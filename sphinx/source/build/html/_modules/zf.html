

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>zf &mdash; zf zfr documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="../genindex.html"/>
        <link rel="search" title="Search" href="../search.html"/>
    <link rel="top" title="zf zfr documentation" href="../index.html"/>
        <link rel="up" title="Module code" href="index.html"/> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> zf
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <!-- Local TOC -->
              <div class="local-toc"></div>
            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">zf</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">Module code</a> &raquo;</li>
        
      <li>zf</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for zf</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright 2015 The TensorFlow Authors. All Rights Reserved.</span>
<span class="c1">#</span>
<span class="c1"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="c1"># you may not use this file except in compliance with the License.</span>
<span class="c1"># You may obtain a copy of the License at</span>
<span class="c1">#</span>
<span class="c1">#     http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="c1">#</span>
<span class="c1"># Unless required by applicable law or agreed to in writing, software</span>
<span class="c1"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="c1"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="c1"># See the License for the specific language governing permissions and</span>
<span class="c1"># limitations under the License.</span>
<span class="c1"># ==============================================================================</span>
<span class="sd">&quot;&quot;&quot;Training-related part of the Keras engine.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">absolute_import</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">division</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">print_function</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">tensorflow.python.eager</span> <span class="k">import</span> <span class="n">context</span>
<span class="kn">from</span> <span class="nn">tensorflow.python.framework</span> <span class="k">import</span> <span class="n">ops</span>
<span class="kn">from</span> <span class="nn">tensorflow.python.framework</span> <span class="k">import</span> <span class="n">tensor_util</span>
<span class="kn">from</span> <span class="nn">tensorflow.python.keras._impl.keras</span> <span class="k">import</span> <span class="n">backend</span> <span class="k">as</span> <span class="n">K</span>
<span class="kn">from</span> <span class="nn">tensorflow.python.keras._impl.keras</span> <span class="k">import</span> <span class="n">losses</span>
<span class="kn">from</span> <span class="nn">tensorflow.python.keras._impl.keras</span> <span class="k">import</span> <span class="n">metrics</span> <span class="k">as</span> <span class="n">metrics_module</span>
<span class="kn">from</span> <span class="nn">tensorflow.python.keras._impl.keras</span> <span class="k">import</span> <span class="n">optimizers</span>
<span class="kn">from</span> <span class="nn">tensorflow.python.keras._impl.keras.engine</span> <span class="k">import</span> <span class="n">training_arrays</span>
<span class="kn">from</span> <span class="nn">tensorflow.python.keras._impl.keras.engine</span> <span class="k">import</span> <span class="n">training_eager</span>
<span class="kn">from</span> <span class="nn">tensorflow.python.keras._impl.keras.engine</span> <span class="k">import</span> <span class="n">training_generator</span>
<span class="kn">from</span> <span class="nn">tensorflow.python.keras._impl.keras.engine</span> <span class="k">import</span> <span class="n">training_utils</span>
<span class="kn">from</span> <span class="nn">tensorflow.python.keras._impl.keras.engine.base_layer</span> <span class="k">import</span> <span class="n">Layer</span>
<span class="kn">from</span> <span class="nn">tensorflow.python.keras._impl.keras.engine.network</span> <span class="k">import</span> <span class="n">Network</span>
<span class="kn">from</span> <span class="nn">tensorflow.python.keras._impl.keras.utils.generic_utils</span> <span class="k">import</span> <span class="n">slice_arrays</span>
<span class="kn">from</span> <span class="nn">tensorflow.python.layers.base</span> <span class="k">import</span> <span class="n">_DeferredTensor</span>
<span class="kn">from</span> <span class="nn">tensorflow.python.ops</span> <span class="k">import</span> <span class="n">array_ops</span>
<span class="kn">from</span> <span class="nn">tensorflow.python.platform</span> <span class="k">import</span> <span class="n">tf_logging</span> <span class="k">as</span> <span class="n">logging</span>
<span class="kn">from</span> <span class="nn">tensorflow.python.training</span> <span class="k">import</span> <span class="n">optimizer</span> <span class="k">as</span> <span class="n">tf_optimizer_module</span>
<span class="kn">from</span> <span class="nn">tensorflow.python.util.tf_export</span> <span class="k">import</span> <span class="n">tf_export</span>


<div class="viewcode-block" id="Model"><a class="viewcode-back" href="../zf.html#zf.Model">[docs]</a><span class="nd">@tf_export</span><span class="p">(</span><span class="s1">&#39;keras.models.Model&#39;</span><span class="p">,</span> <span class="s1">&#39;keras.Model&#39;</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">Model</span><span class="p">(</span><span class="n">Network</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  `Model` groups layers into an object with training and inference features.</span>
<span class="sd">  There are two ways to instantiate a `Model`:</span>

<span class="sd">  Arguments:</span>
<span class="sd">      optimizer: String (name of optimizer) or optimizer instance.</span>
<span class="sd">          See [optimizers](/optimizers).</span>
<span class="sd">      loss: String (name of objective function) or objective function.</span>
<span class="sd">          See [losses](/losses).</span>
<span class="sd">          If the model has multiple outputs, you can use a different loss</span>
<span class="sd">          on each output by passing a dictionary or a list of losses.</span>
<span class="sd">          The loss value that will be minimized by the model</span>
<span class="sd">          will then be the sum of all individual losses.</span>

<span class="sd">  Returns:</span>
<span class="sd">      A tuple of 3 lists: input arrays, target arrays, sample-weight arrays.</span>
<span class="sd">          If the model&#39;s input and targets are symbolic, these lists are empty</span>
<span class="sd">          (since the model takes no user-provided data, instead the data comes</span>
<span class="sd">          from the symbolic inputs/targets).</span>

<span class="sd">  Raises:</span>
<span class="sd">      ValueError: In case of invalid arguments for</span>
<span class="sd">          `optimizer`, `loss`, `metrics` or `sample_weight_mode`.</span>


<span class="sd">  Examples:</span>
<span class="sd">    &gt;&gt;&gt; import tensorflow as tf</span>
<span class="sd">    &gt;&gt;&gt; inputs = tf.keras.Input(shape=(3,))</span>
<span class="sd">    &gt;&gt;&gt; x = tf.keras.layers.Dense(4, activation=tf.nn.relu)(inputs)</span>
<span class="sd">    &gt;&gt;&gt; outputs = tf.keras.layers.Dense(5, activation=tf.nn.softmax)(x)</span>
<span class="sd">    &gt;&gt;&gt; model = tf.keras.Model(inputs=inputs, outputs=outputs)</span>


<span class="sd">  Examples:</span>
<span class="sd">    &gt;&gt;&gt; import tensorflow as tf</span>
<span class="sd">    &gt;&gt;&gt; class MyModel(tf.keras.Model):</span>
<span class="sd">    &gt;&gt;&gt; def __init__(self):</span>
<span class="sd">    &gt;&gt;&gt;   self.dense1 = tf.keras.layers.Dense(4, activation=tf.nn.relu)</span>
<span class="sd">    &gt;&gt;&gt;   self.dense2 = tf.keras.layers.Dense(5, activation=tf.nn.softmax)</span>
<span class="sd">    &gt;&gt;&gt;   def call(self, inputs):</span>
<span class="sd">    &gt;&gt;&gt;   x = self.dense1(inputs)</span>
<span class="sd">    &gt;&gt;&gt;   return self.dense2(x)</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; model = MyModel()</span>

<span class="sd">     &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Model.compile"><a class="viewcode-back" href="../zf.html#zf.Model.compile">[docs]</a>  <span class="k">def</span> <span class="nf">compile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
              <span class="n">optimizer</span><span class="p">,</span>
              <span class="n">loss</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
              <span class="n">metrics</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
              <span class="n">loss_weights</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
              <span class="n">sample_weight_mode</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
              <span class="n">weighted_metrics</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
              <span class="n">target_tensors</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
              <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Configures the model for training.</span>

<span class="sd">    Arguments:</span>
<span class="sd">        optimizer: String (name of optimizer) or optimizer instance.</span>
<span class="sd">            See [optimizers](/optimizers).</span>
<span class="sd">        loss: String (name of objective function) or objective function.</span>
<span class="sd">            See [losses](/losses).</span>
<span class="sd">            If the model has multiple outputs, you can use a different loss</span>
<span class="sd">            on each output by passing a dictionary or a list of losses.</span>
<span class="sd">            The loss value that will be minimized by the model</span>
<span class="sd">            will then be the sum of all individual losses.</span>
<span class="sd">        metrics: List of metrics to be evaluated by the model</span>
<span class="sd">            during training and testing.</span>
<span class="sd">            Typically you will use `metrics=[&#39;accuracy&#39;]`.</span>
<span class="sd">            To specify different metrics for different outputs of a</span>
<span class="sd">            multi-output model, you could also pass a dictionary,</span>
<span class="sd">            such as `metrics={&#39;output_a&#39;: &#39;accuracy&#39;}`.</span>
<span class="sd">        loss_weights: Optional list or dictionary specifying scalar</span>
<span class="sd">            coefficients (Python floats) to weight the loss contributions</span>
<span class="sd">            of different model outputs.</span>
<span class="sd">            The loss value that will be minimized by the model</span>
<span class="sd">            will then be the *weighted sum* of all individual losses,</span>
<span class="sd">            weighted by the `loss_weights` coefficients.</span>
<span class="sd">            If a list, it is expected to have a 1:1 mapping</span>
<span class="sd">            to the model&#39;s outputs. If a tensor, it is expected to map</span>
<span class="sd">            output names (strings) to scalar coefficients.</span>
<span class="sd">        sample_weight_mode: If you need to do timestep-wise</span>
<span class="sd">            sample weighting (2D weights), set this to `&quot;temporal&quot;`.</span>
<span class="sd">            `None` defaults to sample-wise weights (1D).</span>
<span class="sd">            If the model has multiple outputs, you can use a different</span>
<span class="sd">            `sample_weight_mode` on each output by passing a</span>
<span class="sd">            dictionary or a list of modes.</span>
<span class="sd">        weighted_metrics: List of metrics to be evaluated and weighted</span>
<span class="sd">            by sample_weight or class_weight during training and testing.</span>
<span class="sd">        target_tensors: By default, Keras will create placeholders for the</span>
<span class="sd">            model&#39;s target, which will be fed with the target data during</span>
<span class="sd">            training. If instead you would like to use your own</span>
<span class="sd">            target tensors (in turn, Keras will not expect external</span>
<span class="sd">            Numpy data for these targets at training time), you</span>
<span class="sd">            can specify them via the `target_tensors` argument. It can be</span>
<span class="sd">            a single tensor (for a single-output model), a list of tensors,</span>
<span class="sd">            or a dict mapping output names to target tensors.</span>
<span class="sd">        **kwargs: These arguments are passed to `tf.Session.run`.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: In case of invalid arguments for</span>
<span class="sd">            `optimizer`, `loss`, `metrics` or `sample_weight_mode`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">loss</span> <span class="o">=</span> <span class="n">loss</span> <span class="ow">or</span> <span class="p">{}</span>
    <span class="k">if</span> <span class="n">context</span><span class="o">.</span><span class="n">executing_eagerly</span><span class="p">()</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span>
        <span class="n">optimizer</span><span class="p">,</span> <span class="p">(</span><span class="n">tf_optimizer_module</span><span class="o">.</span><span class="n">Optimizer</span><span class="p">,</span> <span class="n">optimizers</span><span class="o">.</span><span class="n">TFOptimizer</span><span class="p">)):</span>
      <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Only TF native optimizers are supported in Eager mode.&#39;</span><span class="p">)</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">optimizer</span> <span class="o">=</span> <span class="n">optimizers</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">optimizer</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">loss</span> <span class="o">=</span> <span class="n">loss</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">metrics</span> <span class="o">=</span> <span class="n">metrics</span> <span class="ow">or</span> <span class="p">[]</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">loss_weights</span> <span class="o">=</span> <span class="n">loss_weights</span>
    <span class="k">if</span> <span class="n">context</span><span class="o">.</span><span class="n">executing_eagerly</span><span class="p">()</span> <span class="ow">and</span> <span class="n">sample_weight_mode</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;sample_weight_mode is not supported in Eager mode.&#39;</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">sample_weight_mode</span> <span class="o">=</span> <span class="n">sample_weight_mode</span>
    <span class="k">if</span> <span class="n">context</span><span class="o">.</span><span class="n">executing_eagerly</span><span class="p">()</span> <span class="ow">and</span> <span class="n">weighted_metrics</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;weighted_metrics is not supported in Eager mode.&#39;</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">weighted_metrics</span> <span class="o">=</span> <span class="n">weighted_metrics</span>
    <span class="k">if</span> <span class="n">context</span><span class="o">.</span><span class="n">executing_eagerly</span><span class="p">()</span> <span class="ow">and</span> <span class="n">target_tensors</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;target_tensors is not supported in Eager mode.&#39;</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">target_tensors</span> <span class="o">=</span> <span class="n">target_tensors</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">built</span><span class="p">:</span>
      <span class="c1"># Model is not compilable because it does not know its number of inputs</span>
      <span class="c1"># and outputs, nor their shapes and names. We will compile after the first</span>
      <span class="c1"># time the model gets called on training data.</span>
      <span class="k">return</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_is_compiled</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="c1"># Prepare loss functions.</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">loss</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
      <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">loss</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_names</span><span class="p">:</span>
          <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
              <span class="s1">&#39;Unknown entry in loss &#39;</span>
              <span class="s1">&#39;dictionary: &quot;&#39;</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;&quot;. &#39;</span>
              <span class="s1">&#39;Only expected the following keys: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_names</span><span class="p">))</span>
      <span class="n">loss_functions</span> <span class="o">=</span> <span class="p">[]</span>
      <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_names</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">loss</span><span class="p">:</span>
          <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
              <span class="s1">&#39;Output &quot;&#39;</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;&quot; missing from loss dictionary. &#39;</span>
              <span class="s1">&#39;We assume this was done on purpose, &#39;</span>
              <span class="s1">&#39;and we will not be expecting &#39;</span>
              <span class="s1">&#39;any data to be passed to &quot;&#39;</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;&quot; during training.&#39;</span><span class="p">)</span>
        <span class="n">loss_functions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">losses</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">loss</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name</span><span class="p">)))</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">loss</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
      <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">loss</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outputs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;When passing a list as loss, &#39;</span>
                         <span class="s1">&#39;it should have one entry per model outputs. &#39;</span>
                         <span class="s1">&#39;The model has &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outputs</span><span class="p">))</span> <span class="o">+</span>
                         <span class="s1">&#39; outputs, but you passed loss=&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">loss</span><span class="p">))</span>
      <span class="n">loss_functions</span> <span class="o">=</span> <span class="p">[</span><span class="n">losses</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">loss</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">loss_function</span> <span class="o">=</span> <span class="n">losses</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">loss</span><span class="p">)</span>
      <span class="n">loss_functions</span> <span class="o">=</span> <span class="p">[</span><span class="n">loss_function</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outputs</span><span class="p">))]</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">loss_functions</span> <span class="o">=</span> <span class="n">loss_functions</span>

    <span class="n">weighted_losses</span> <span class="o">=</span> <span class="p">[</span><span class="n">training_utils</span><span class="o">.</span><span class="n">weighted_masked_objective</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
                       <span class="k">for</span> <span class="n">fn</span> <span class="ow">in</span> <span class="n">loss_functions</span><span class="p">]</span>
    <span class="n">skip_target_indices</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">skip_target_weighing_indices</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_feed_outputs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_feed_output_names</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_feed_output_shapes</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_feed_loss_fns</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">weighted_losses</span><span class="p">)):</span>
      <span class="k">if</span> <span class="n">weighted_losses</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">skip_target_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="n">skip_target_weighing_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

    <span class="c1"># Prepare output masks.</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">context</span><span class="o">.</span><span class="n">executing_eagerly</span><span class="p">():</span>
      <span class="n">masks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_mask</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
      <span class="k">if</span> <span class="n">masks</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">masks</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">outputs</span><span class="p">]</span>
      <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">masks</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">masks</span> <span class="o">=</span> <span class="p">[</span><span class="n">masks</span><span class="p">]</span>

    <span class="c1"># Prepare loss weights.</span>
    <span class="k">if</span> <span class="n">loss_weights</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
      <span class="n">loss_weights_list</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outputs</span><span class="p">))]</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">loss_weights</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
      <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">loss_weights</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_names</span><span class="p">:</span>
          <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
              <span class="s1">&#39;Unknown entry in loss_weights &#39;</span>
              <span class="s1">&#39;dictionary: &quot;&#39;</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;&quot;. &#39;</span>
              <span class="s1">&#39;Only expected the following keys: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_names</span><span class="p">))</span>
      <span class="n">loss_weights_list</span> <span class="o">=</span> <span class="p">[]</span>
      <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_names</span><span class="p">:</span>
        <span class="n">loss_weights_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">loss_weights</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="mf">1.</span><span class="p">))</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">loss_weights</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
      <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">loss_weights</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outputs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s1">&#39;When passing a list as loss_weights, &#39;</span>
            <span class="s1">&#39;it should have one entry per model output. &#39;</span>
            <span class="s1">&#39;The model has &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outputs</span><span class="p">))</span> <span class="o">+</span>
            <span class="s1">&#39; outputs, but you passed loss_weights=&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">loss_weights</span><span class="p">))</span>
      <span class="n">loss_weights_list</span> <span class="o">=</span> <span class="n">loss_weights</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Could not interpret loss_weights argument: &#39;</span> <span class="o">+</span>
                      <span class="nb">str</span><span class="p">(</span><span class="n">loss_weights</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; - expected a list of dicts.&#39;</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">loss_weights_list</span> <span class="o">=</span> <span class="n">loss_weights_list</span>

    <span class="c1"># initialization for Eager mode execution</span>
    <span class="k">if</span> <span class="n">context</span><span class="o">.</span><span class="n">executing_eagerly</span><span class="p">():</span>
      <span class="k">if</span> <span class="n">target_tensors</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;target_tensors are not currently supported in Eager &#39;</span>
                         <span class="s1">&#39;mode.&#39;</span><span class="p">)</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">total_loss</span> <span class="o">=</span> <span class="kc">None</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">metrics_tensors</span> <span class="o">=</span> <span class="p">[]</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">metrics_names</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;loss&#39;</span><span class="p">]</span>
      <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outputs</span><span class="p">)):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outputs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
          <span class="bp">self</span><span class="o">.</span><span class="n">metrics_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_names</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;_loss&#39;</span><span class="p">)</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">nested_metrics</span> <span class="o">=</span> <span class="n">training_utils</span><span class="o">.</span><span class="n">collect_metrics</span><span class="p">(</span><span class="n">metrics</span><span class="p">,</span>
                                                           <span class="bp">self</span><span class="o">.</span><span class="n">output_names</span><span class="p">)</span>
      <span class="k">with</span> <span class="n">K</span><span class="o">.</span><span class="n">name_scope</span><span class="p">(</span><span class="s1">&#39;metrics&#39;</span><span class="p">):</span>
        <span class="n">training_utils</span><span class="o">.</span><span class="n">populate_metric_names</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">_feed_sample_weight_modes</span> <span class="o">=</span> <span class="p">[]</span>
      <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outputs</span><span class="p">)):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_feed_sample_weight_modes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">sample_weights</span> <span class="o">=</span> <span class="p">[]</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">targets</span> <span class="o">=</span> <span class="p">[]</span>
      <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outputs</span><span class="p">)):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_feed_output_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_names</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">_collected_trainable_weights</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">trainable_weights</span>
      <span class="k">return</span>

    <span class="c1"># Prepare targets of model.</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">targets</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_feed_targets</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">target_tensors</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="p">[]):</span>
      <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">target_tensors</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">target_tensors</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outputs</span><span class="p">):</span>
          <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
              <span class="s1">&#39;When passing a list as `target_tensors`, &#39;</span>
              <span class="s1">&#39;it should have one entry per model output. &#39;</span>
              <span class="s1">&#39;The model has &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outputs</span><span class="p">))</span> <span class="o">+</span>
              <span class="s1">&#39; outputs, but you passed target_tensors=&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">target_tensors</span><span class="p">))</span>
      <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">target_tensors</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">target_tensors</span><span class="p">:</span>
          <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_names</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;Unknown entry in `target_tensors` &#39;</span>
                <span class="s1">&#39;dictionary: &quot;&#39;</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;&quot;. &#39;</span>
                <span class="s1">&#39;Only expected the following keys: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_names</span><span class="p">))</span>
        <span class="n">tmp_target_tensors</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_names</span><span class="p">:</span>
          <span class="n">tmp_target_tensors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">target_tensors</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
        <span class="n">target_tensors</span> <span class="o">=</span> <span class="n">tmp_target_tensors</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Expected `target_tensors` to be &#39;</span>
                        <span class="s1">&#39;a list or dict, but got:&#39;</span><span class="p">,</span> <span class="n">target_tensors</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outputs</span><span class="p">)):</span>
      <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">skip_target_indices</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">targets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="n">K</span><span class="o">.</span><span class="n">int_shape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outputs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_names</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">target_tensors</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="p">[]):</span>
          <span class="n">target</span> <span class="o">=</span> <span class="n">target_tensors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
          <span class="n">target</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">target</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">K</span><span class="o">.</span><span class="n">is_placeholder</span><span class="p">(</span><span class="n">target</span><span class="p">):</span>
          <span class="k">if</span> <span class="n">target</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">target</span> <span class="o">=</span> <span class="n">K</span><span class="o">.</span><span class="n">placeholder</span><span class="p">(</span>
                <span class="n">ndim</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">),</span>
                <span class="n">name</span><span class="o">=</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;_target&#39;</span><span class="p">,</span>
                <span class="n">sparse</span><span class="o">=</span><span class="n">K</span><span class="o">.</span><span class="n">is_sparse</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outputs</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span>
                <span class="n">dtype</span><span class="o">=</span><span class="n">K</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outputs</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
          <span class="bp">self</span><span class="o">.</span><span class="n">_feed_targets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
          <span class="bp">self</span><span class="o">.</span><span class="n">_feed_outputs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outputs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
          <span class="bp">self</span><span class="o">.</span><span class="n">_feed_output_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
          <span class="bp">self</span><span class="o">.</span><span class="n">_feed_output_shapes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
          <span class="bp">self</span><span class="o">.</span><span class="n">_feed_loss_fns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loss_functions</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
          <span class="n">skip_target_weighing_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">targets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>

    <span class="c1"># Prepare sample weights.</span>
    <span class="n">sample_weights</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">sample_weight_modes</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sample_weight_mode</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
      <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">sample_weight_mode</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_names</span><span class="p">:</span>
          <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
              <span class="s1">&#39;Unknown entry in &#39;</span>
              <span class="s1">&#39;sample_weight_mode dictionary: &quot;&#39;</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;&quot;. &#39;</span>
              <span class="s1">&#39;Only expected the following keys: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_names</span><span class="p">))</span>
      <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_names</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">skip_target_weighing_indices</span><span class="p">:</span>
          <span class="n">weight</span> <span class="o">=</span> <span class="kc">None</span>
          <span class="n">sample_weight_modes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
          <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">sample_weight_mode</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;Output &quot;&#39;</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;&quot; missing from sample_weight_modes &#39;</span>
                <span class="s1">&#39;dictionary&#39;</span><span class="p">)</span>
          <span class="k">if</span> <span class="n">sample_weight_mode</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;temporal&#39;</span><span class="p">:</span>
            <span class="n">weight</span> <span class="o">=</span> <span class="n">K</span><span class="o">.</span><span class="n">placeholder</span><span class="p">(</span><span class="n">ndim</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;_sample_weights&#39;</span><span class="p">)</span>
            <span class="n">sample_weight_modes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;temporal&#39;</span><span class="p">)</span>
          <span class="k">else</span><span class="p">:</span>
            <span class="n">weight</span> <span class="o">=</span> <span class="n">K</span><span class="o">.</span><span class="n">placeholder</span><span class="p">(</span><span class="n">ndim</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;sample_weights&#39;</span><span class="p">)</span>
            <span class="n">sample_weight_modes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="n">sample_weights</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">weight</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sample_weight_mode</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
      <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sample_weight_mode</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outputs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;When passing a list as sample_weight_mode, &#39;</span>
                         <span class="s1">&#39;it should have one entry per model output. &#39;</span>
                         <span class="s1">&#39;The model has &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outputs</span><span class="p">))</span> <span class="o">+</span>
                         <span class="s1">&#39; outputs, but you passed &#39;</span>
                         <span class="s1">&#39;sample_weight_mode=&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">sample_weight_mode</span><span class="p">))</span>
      <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_names</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">skip_target_weighing_indices</span><span class="p">:</span>
          <span class="n">weight</span> <span class="o">=</span> <span class="kc">None</span>
          <span class="n">sample_weight_modes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
          <span class="n">mode</span> <span class="o">=</span> <span class="n">sample_weight_mode</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
          <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_names</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
          <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;temporal&#39;</span><span class="p">:</span>
            <span class="n">weight</span> <span class="o">=</span> <span class="n">K</span><span class="o">.</span><span class="n">placeholder</span><span class="p">(</span><span class="n">ndim</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;_sample_weights&#39;</span><span class="p">)</span>
            <span class="n">sample_weight_modes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;temporal&#39;</span><span class="p">)</span>
          <span class="k">else</span><span class="p">:</span>
            <span class="n">weight</span> <span class="o">=</span> <span class="n">K</span><span class="o">.</span><span class="n">placeholder</span><span class="p">(</span><span class="n">ndim</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;_sample_weights&#39;</span><span class="p">)</span>
            <span class="n">sample_weight_modes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="n">sample_weights</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">weight</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_names</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">skip_target_weighing_indices</span><span class="p">:</span>
          <span class="n">sample_weight_modes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
          <span class="n">sample_weights</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
          <span class="k">if</span> <span class="n">sample_weight_mode</span> <span class="o">==</span> <span class="s1">&#39;temporal&#39;</span><span class="p">:</span>
            <span class="n">sample_weights</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">array_ops</span><span class="o">.</span><span class="n">placeholder_with_default</span><span class="p">(</span>
                <span class="p">[[</span><span class="mf">1.</span><span class="p">]],</span> <span class="n">shape</span><span class="o">=</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">],</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;_sample_weights&#39;</span><span class="p">))</span>
            <span class="n">sample_weight_modes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;temporal&#39;</span><span class="p">)</span>
          <span class="k">else</span><span class="p">:</span>
            <span class="n">sample_weights</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">array_ops</span><span class="o">.</span><span class="n">placeholder_with_default</span><span class="p">(</span>
                <span class="p">[</span><span class="mf">1.</span><span class="p">],</span> <span class="n">shape</span><span class="o">=</span><span class="p">[</span><span class="kc">None</span><span class="p">],</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;_sample_weights&#39;</span><span class="p">))</span>
            <span class="n">sample_weight_modes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">sample_weight_modes</span> <span class="o">=</span> <span class="n">sample_weight_modes</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_feed_sample_weight_modes</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outputs</span><span class="p">)):</span>
      <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">skip_target_weighing_indices</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_feed_sample_weight_modes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_weight_modes</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

    <span class="c1"># Prepare metrics.</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">weighted_metrics</span> <span class="o">=</span> <span class="n">weighted_metrics</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">metrics_names</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;loss&#39;</span><span class="p">]</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">metrics_tensors</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># Compute total loss.</span>
    <span class="n">total_loss</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">with</span> <span class="n">K</span><span class="o">.</span><span class="n">name_scope</span><span class="p">(</span><span class="s1">&#39;loss&#39;</span><span class="p">):</span>
      <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outputs</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">skip_target_indices</span><span class="p">:</span>
          <span class="k">continue</span>
        <span class="n">y_true</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">targets</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">y_pred</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">outputs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">weighted_loss</span> <span class="o">=</span> <span class="n">weighted_losses</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">sample_weight</span> <span class="o">=</span> <span class="n">sample_weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">masks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">loss_weight</span> <span class="o">=</span> <span class="n">loss_weights_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">with</span> <span class="n">K</span><span class="o">.</span><span class="n">name_scope</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_names</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;_loss&#39;</span><span class="p">):</span>
          <span class="n">output_loss</span> <span class="o">=</span> <span class="n">weighted_loss</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">,</span> <span class="n">sample_weight</span><span class="p">,</span> <span class="n">mask</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outputs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
          <span class="bp">self</span><span class="o">.</span><span class="n">metrics_tensors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">output_loss</span><span class="p">)</span>
          <span class="bp">self</span><span class="o">.</span><span class="n">metrics_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_names</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;_loss&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">total_loss</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
          <span class="n">total_loss</span> <span class="o">=</span> <span class="n">loss_weight</span> <span class="o">*</span> <span class="n">output_loss</span>
        <span class="k">else</span><span class="p">:</span>
          <span class="n">total_loss</span> <span class="o">+=</span> <span class="n">loss_weight</span> <span class="o">*</span> <span class="n">output_loss</span>
      <span class="k">if</span> <span class="n">total_loss</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">losses</span><span class="p">:</span>
          <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The model cannot be compiled &#39;</span>
                           <span class="s1">&#39;because it has no loss to optimize.&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
          <span class="n">total_loss</span> <span class="o">=</span> <span class="mf">0.</span>

      <span class="c1"># Add regularization penalties</span>
      <span class="c1"># and other layer-specific losses.</span>
      <span class="k">for</span> <span class="n">loss_tensor</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">losses</span><span class="p">:</span>
        <span class="n">total_loss</span> <span class="o">+=</span> <span class="n">loss_tensor</span>

    <span class="c1"># List of same size as output_names.</span>
    <span class="c1"># contains tuples (metrics for output, names of metrics).</span>
    <span class="n">nested_metrics</span> <span class="o">=</span> <span class="n">training_utils</span><span class="o">.</span><span class="n">collect_metrics</span><span class="p">(</span><span class="n">metrics</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_names</span><span class="p">)</span>
    <span class="n">nested_weighted_metrics</span> <span class="o">=</span> <span class="n">training_utils</span><span class="o">.</span><span class="n">collect_metrics</span><span class="p">(</span><span class="n">weighted_metrics</span><span class="p">,</span>
                                                             <span class="bp">self</span><span class="o">.</span><span class="n">output_names</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">metrics_updates</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">stateful_metric_names</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">with</span> <span class="n">K</span><span class="o">.</span><span class="n">name_scope</span><span class="p">(</span><span class="s1">&#39;metrics&#39;</span><span class="p">):</span>
      <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outputs</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">skip_target_indices</span><span class="p">:</span>
          <span class="k">continue</span>

        <span class="n">y_true</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">targets</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">y_pred</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">outputs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="n">sample_weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">output_metrics</span> <span class="o">=</span> <span class="n">nested_metrics</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">output_weighted_metrics</span> <span class="o">=</span> <span class="n">nested_weighted_metrics</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

        <span class="k">def</span> <span class="nf">handle_metrics</span><span class="p">(</span><span class="n">metrics</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

          <span class="k">for</span> <span class="n">metric</span> <span class="ow">in</span> <span class="n">metrics</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">metric</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;accuracy&#39;</span><span class="p">,</span> <span class="s1">&#39;acc&#39;</span><span class="p">,</span> <span class="s1">&#39;crossentropy&#39;</span><span class="p">,</span> <span class="s1">&#39;ce&#39;</span><span class="p">):</span>
              <span class="c1"># custom handling of accuracy/crossentropy</span>
              <span class="c1"># (because of class mode duality)</span>
              <span class="n">output_shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">outputs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">get_shape</span><span class="p">()</span><span class="o">.</span><span class="n">as_list</span><span class="p">()</span>
              <span class="k">if</span> <span class="p">(</span><span class="n">output_shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">or</span>
                  <span class="bp">self</span><span class="o">.</span><span class="n">loss_functions</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">losses</span><span class="o">.</span><span class="n">binary_crossentropy</span><span class="p">):</span>
                <span class="c1"># case: binary accuracy/crossentropy</span>
                <span class="k">if</span> <span class="n">metric</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;accuracy&#39;</span><span class="p">,</span> <span class="s1">&#39;acc&#39;</span><span class="p">):</span>
                  <span class="n">metric_fn</span> <span class="o">=</span> <span class="n">metrics_module</span><span class="o">.</span><span class="n">binary_accuracy</span>
                <span class="k">elif</span> <span class="n">metric</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;crossentropy&#39;</span><span class="p">,</span> <span class="s1">&#39;ce&#39;</span><span class="p">):</span>
                  <span class="n">metric_fn</span> <span class="o">=</span> <span class="n">metrics_module</span><span class="o">.</span><span class="n">binary_crossentropy</span>
              <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">loss_functions</span><span class="p">[</span>
                  <span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">losses</span><span class="o">.</span><span class="n">sparse_categorical_crossentropy</span><span class="p">:</span>
                <span class="c1"># case: categorical accuracy/crossentropy with sparse targets</span>
                <span class="k">if</span> <span class="n">metric</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;accuracy&#39;</span><span class="p">,</span> <span class="s1">&#39;acc&#39;</span><span class="p">):</span>
                  <span class="n">metric_fn</span> <span class="o">=</span> <span class="n">metrics_module</span><span class="o">.</span><span class="n">sparse_categorical_accuracy</span>
                <span class="k">elif</span> <span class="n">metric</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;crossentropy&#39;</span><span class="p">,</span> <span class="s1">&#39;ce&#39;</span><span class="p">):</span>
                  <span class="n">metric_fn</span> <span class="o">=</span> <span class="n">metrics_module</span><span class="o">.</span><span class="n">sparse_categorical_crossentropy</span>
              <span class="k">else</span><span class="p">:</span>
                <span class="c1"># case: categorical accuracy/crossentropy</span>
                <span class="k">if</span> <span class="n">metric</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;accuracy&#39;</span><span class="p">,</span> <span class="s1">&#39;acc&#39;</span><span class="p">):</span>
                  <span class="n">metric_fn</span> <span class="o">=</span> <span class="n">metrics_module</span><span class="o">.</span><span class="n">categorical_accuracy</span>
                <span class="k">elif</span> <span class="n">metric</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;crossentropy&#39;</span><span class="p">,</span> <span class="s1">&#39;ce&#39;</span><span class="p">):</span>
                  <span class="n">metric_fn</span> <span class="o">=</span> <span class="n">metrics_module</span><span class="o">.</span><span class="n">categorical_crossentropy</span>
              <span class="n">weighted_metric_fn</span> <span class="o">=</span> <span class="n">training_utils</span><span class="o">.</span><span class="n">weighted_masked_objective</span><span class="p">(</span>
                  <span class="n">metric_fn</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
              <span class="n">metric_fn</span> <span class="o">=</span> <span class="n">metrics_module</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">metric</span><span class="p">)</span>
              <span class="n">weighted_metric_fn</span> <span class="o">=</span> <span class="n">training_utils</span><span class="o">.</span><span class="n">weighted_masked_objective</span><span class="p">(</span>
                  <span class="n">metric_fn</span><span class="p">)</span>
            <span class="n">metric_name</span> <span class="o">=</span> <span class="n">training_utils</span><span class="o">.</span><span class="n">get_base_metric_name</span><span class="p">(</span>
                <span class="n">metric</span><span class="p">,</span> <span class="n">weighted</span><span class="o">=</span><span class="n">weights</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">with</span> <span class="n">K</span><span class="o">.</span><span class="n">name_scope</span><span class="p">(</span><span class="n">metric_name</span><span class="p">):</span>
              <span class="n">metric_result</span> <span class="o">=</span> <span class="n">weighted_metric_fn</span><span class="p">(</span>
                  <span class="n">y_true</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">weights</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">masks</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

            <span class="n">training_utils</span><span class="o">.</span><span class="n">add_metric_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">metric_name</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">metrics_tensors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">metric_result</span><span class="p">)</span>

            <span class="c1"># Keep track of state updates created by</span>
            <span class="c1"># stateful metrics (i.e. metrics layers).</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">metric_fn</span><span class="p">,</span> <span class="n">Layer</span><span class="p">):</span>
              <span class="bp">self</span><span class="o">.</span><span class="n">stateful_metric_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">metric_name</span><span class="p">)</span>
              <span class="bp">self</span><span class="o">.</span><span class="n">metrics_updates</span> <span class="o">+=</span> <span class="n">metric_fn</span><span class="o">.</span><span class="n">updates</span>

        <span class="n">handle_metrics</span><span class="p">(</span><span class="n">output_metrics</span><span class="p">)</span>
        <span class="n">handle_metrics</span><span class="p">(</span><span class="n">output_weighted_metrics</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">weights</span><span class="p">)</span>

    <span class="c1"># Prepare gradient updates and state updates.</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">total_loss</span> <span class="o">=</span> <span class="n">total_loss</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">sample_weights</span> <span class="o">=</span> <span class="n">sample_weights</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_feed_sample_weights</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_weights</span><span class="p">)):</span>
      <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">skip_target_weighing_indices</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_feed_sample_weights</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_weights</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

    <span class="c1"># Functions for train, test and predict will</span>
    <span class="c1"># be compiled lazily when required.</span>
    <span class="c1"># This saves time when the user is not using all functions.</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_function_kwargs</span> <span class="o">=</span> <span class="n">kwargs</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">train_function</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">test_function</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">predict_function</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># Collected trainable weights, sorted in topological order.</span>
    <span class="n">trainable_weights</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">trainable_weights</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_collected_trainable_weights</span> <span class="o">=</span> <span class="n">trainable_weights</span></div>

  <span class="k">def</span> <span class="nf">_check_trainable_weights_consistency</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Check trainable weights count consistency.</span>

<span class="sd">    This will raise a warning if `trainable_weights` and</span>
<span class="sd">    `_collected_trainable_weights` are inconsistent (i.e. have different</span>
<span class="sd">    number of parameters).</span>
<span class="sd">    Inconsistency will typically arise when one modifies `model.trainable`</span>
<span class="sd">    without calling `model.compile` again.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_collected_trainable_weights&#39;</span><span class="p">):</span>
      <span class="k">return</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">trainable_weights</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_collected_trainable_weights</span><span class="p">):</span>
      <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
          <span class="ne">UserWarning</span><span class="p">(</span>
              <span class="s1">&#39;Discrepancy between trainable weights and collected trainable&#39;</span>
              <span class="s1">&#39; weights, did you set `model.trainable` without calling&#39;</span>
              <span class="s1">&#39; `model.compile` after ?&#39;</span><span class="p">))</span>

  <span class="k">def</span> <span class="nf">_make_train_function</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;train_function&#39;</span><span class="p">):</span>
      <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;You must compile your model before using it.&#39;</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_check_trainable_weights_consistency</span><span class="p">()</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">train_function</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
      <span class="n">inputs</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_feed_inputs</span> <span class="o">+</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_feed_targets</span> <span class="o">+</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_feed_sample_weights</span><span class="p">)</span>
      <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">uses_learning_phase</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">K</span><span class="o">.</span><span class="n">learning_phase</span><span class="p">(),</span> <span class="nb">int</span><span class="p">):</span>
        <span class="n">inputs</span> <span class="o">+=</span> <span class="p">[</span><span class="n">K</span><span class="o">.</span><span class="n">learning_phase</span><span class="p">()]</span>

      <span class="k">with</span> <span class="n">K</span><span class="o">.</span><span class="n">name_scope</span><span class="p">(</span><span class="s1">&#39;training&#39;</span><span class="p">):</span>
        <span class="k">with</span> <span class="n">K</span><span class="o">.</span><span class="n">name_scope</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">optimizer</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">):</span>
          <span class="c1"># Training updates</span>
          <span class="n">updates</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">optimizer</span><span class="o">.</span><span class="n">get_updates</span><span class="p">(</span>
              <span class="n">params</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_collected_trainable_weights</span><span class="p">,</span> <span class="n">loss</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">total_loss</span><span class="p">)</span>
        <span class="c1"># Unconditional updates</span>
        <span class="n">updates</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_updates_for</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="c1"># Conditional updates relevant to this model</span>
        <span class="n">updates</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_updates_for</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_feed_inputs</span><span class="p">)</span>
        <span class="c1"># Stateful metrics updates</span>
        <span class="n">updates</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metrics_updates</span>
        <span class="c1"># Gets loss and metrics. Updates weights at each call.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">train_function</span> <span class="o">=</span> <span class="n">K</span><span class="o">.</span><span class="n">function</span><span class="p">(</span>
            <span class="n">inputs</span><span class="p">,</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">total_loss</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">metrics_tensors</span><span class="p">,</span>
            <span class="n">updates</span><span class="o">=</span><span class="n">updates</span><span class="p">,</span>
            <span class="n">name</span><span class="o">=</span><span class="s1">&#39;train_function&#39;</span><span class="p">,</span>
            <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_function_kwargs</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">_make_test_function</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;test_function&#39;</span><span class="p">):</span>
      <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;You must compile your model before using it.&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">test_function</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
      <span class="n">inputs</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_feed_inputs</span> <span class="o">+</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_feed_targets</span> <span class="o">+</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_feed_sample_weights</span><span class="p">)</span>
      <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">uses_learning_phase</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">K</span><span class="o">.</span><span class="n">learning_phase</span><span class="p">(),</span> <span class="nb">int</span><span class="p">):</span>
        <span class="n">inputs</span> <span class="o">+=</span> <span class="p">[</span><span class="n">K</span><span class="o">.</span><span class="n">learning_phase</span><span class="p">()]</span>
      <span class="c1"># Return loss and metrics, no gradient updates.</span>
      <span class="c1"># Does update the network states.</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">test_function</span> <span class="o">=</span> <span class="n">K</span><span class="o">.</span><span class="n">function</span><span class="p">(</span>
          <span class="n">inputs</span><span class="p">,</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">total_loss</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">metrics_tensors</span><span class="p">,</span>
          <span class="n">updates</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">state_updates</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">metrics_updates</span><span class="p">,</span>
          <span class="n">name</span><span class="o">=</span><span class="s1">&#39;test_function&#39;</span><span class="p">,</span>
          <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_function_kwargs</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">_make_predict_function</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;predict_function&#39;</span><span class="p">):</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">predict_function</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">predict_function</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
      <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">uses_learning_phase</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">K</span><span class="o">.</span><span class="n">learning_phase</span><span class="p">(),</span> <span class="nb">int</span><span class="p">):</span>
        <span class="n">inputs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_feed_inputs</span> <span class="o">+</span> <span class="p">[</span><span class="n">K</span><span class="o">.</span><span class="n">learning_phase</span><span class="p">()]</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="n">inputs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_feed_inputs</span>
      <span class="c1"># Gets network outputs. Does not update weights.</span>
      <span class="c1"># Does update the network states.</span>
      <span class="n">kwargs</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_function_kwargs&#39;</span><span class="p">,</span> <span class="p">{})</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">predict_function</span> <span class="o">=</span> <span class="n">K</span><span class="o">.</span><span class="n">function</span><span class="p">(</span>
          <span class="n">inputs</span><span class="p">,</span>
          <span class="bp">self</span><span class="o">.</span><span class="n">outputs</span><span class="p">,</span>
          <span class="n">updates</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">state_updates</span><span class="p">,</span>
          <span class="n">name</span><span class="o">=</span><span class="s1">&#39;predict_function&#39;</span><span class="p">,</span>
          <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">_standardize_user_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                             <span class="n">x</span><span class="p">,</span>
                             <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                             <span class="n">sample_weight</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                             <span class="n">class_weight</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                             <span class="n">batch_size</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Runs validation checks on input and target data passed by the user.</span>

<span class="sd">    Also standardizes the data to lists of arrays, in order.</span>

<span class="sd">    Also builds and compiles the model on the fly if it is a subclassed model</span>
<span class="sd">    that has never been called before (and thus has no inputs/outputs).</span>

<span class="sd">    This is a purely internal method, subject to refactoring at any time.</span>

<span class="sd">    Args:</span>
<span class="sd">      x: An array or list of arrays, to be used as input data. If the model</span>
<span class="sd">       has known, named inputs, this could also be a dict mapping input names</span>
<span class="sd">       to the corresponding array.</span>
<span class="sd">      y: An array or list of arrays, to be used as target data. If the model</span>
<span class="sd">       has known, named outputs, this could also be a dict mapping output names</span>
<span class="sd">       to the corresponding array.</span>
<span class="sd">      sample_weight: An optional sample-weight array passed by the user to</span>
<span class="sd">        weight the importance of each sample in `x`.</span>
<span class="sd">      class_weight: An optional class-weight array by the user to</span>
<span class="sd">        weight the importance of samples in `x` based on the class they belong</span>
<span class="sd">        to, as conveyed by `y`.</span>
<span class="sd">      batch_size: Integer batch size. If provided, it is used to run additional</span>
<span class="sd">        validation checks on stateful models.</span>

<span class="sd">    Returns:</span>
<span class="sd">      A tuple of 3 lists: input arrays, target arrays, sample-weight arrays.</span>
<span class="sd">      If the model&#39;s input and targets are symbolic, these lists are empty</span>
<span class="sd">      (since the model takes no user-provided data, instead the data comes</span>
<span class="sd">      from the symbolic inputs/targets).</span>

<span class="sd">    Raises:</span>
<span class="sd">      ValueError: In case of invalid user-provided data.</span>
<span class="sd">      RuntimeError: If the model was never compiled.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># First, we build/compile the model on the fly if necessary.</span>
    <span class="n">all_inputs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">built</span><span class="p">:</span>
      <span class="c1"># We need to use `x` to set the model inputs.</span>
      <span class="c1"># We type-check that `x` and `y` are either single arrays</span>
      <span class="c1"># or lists of arrays.</span>
      <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">or</span>
                   <span class="n">tensor_util</span><span class="o">.</span><span class="n">is_tensor</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">x</span><span class="p">):</span>
          <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Please provide as model inputs either a single &#39;</span>
                           <span class="s1">&#39;array or a list of arrays. You passed: x=&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
        <span class="n">all_inputs</span> <span class="o">+=</span> <span class="nb">list</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
      <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Please do not pass a dictionary as model inputs.&#39;</span><span class="p">)</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">tensor_util</span><span class="o">.</span><span class="n">is_tensor</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
          <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Please provide as model inputs either a single &#39;</span>
                           <span class="s1">&#39;array or a list of arrays. You passed: x=&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
        <span class="n">all_inputs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

      <span class="c1"># Build the model using the retrieved inputs (value or symbolic).</span>
      <span class="c1"># If values, then in symbolic-mode placeholders will be created</span>
      <span class="c1"># to match the value shapes.</span>
      <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_inputs</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">y</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
      <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">optimizer</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;You must compile a model before &#39;</span>
                           <span class="s1">&#39;training/testing. &#39;</span>
                           <span class="s1">&#39;Use `model.compile(optimizer, loss)`.&#39;</span><span class="p">)</span>
      <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_compiled</span><span class="p">:</span>
        <span class="c1"># On-the-fly compilation of the model.</span>
        <span class="c1"># We need to use `y` to set the model targets.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
          <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">or</span>
                     <span class="n">tensor_util</span><span class="o">.</span><span class="n">is_tensor</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">y</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Please provide as model targets either a single &#39;</span>
                             <span class="s1">&#39;array or a list of arrays. &#39;</span>
                             <span class="s1">&#39;You passed: y=&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
          <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Please do not pass a dictionary as model targets.&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
          <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">tensor_util</span><span class="o">.</span><span class="n">is_tensor</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Please provide as model targets either a single &#39;</span>
                             <span class="s1">&#39;array or a list of arrays. &#39;</span>
                             <span class="s1">&#39;You passed: y=&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>

        <span class="c1"># Typecheck that all inputs are *either* value *or* symbolic.</span>
        <span class="c1"># TODO(fchollet): this check could be removed in Eager mode?</span>
        <span class="k">if</span> <span class="n">y</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
          <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="n">all_inputs</span> <span class="o">+=</span> <span class="nb">list</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
          <span class="k">else</span><span class="p">:</span>
            <span class="n">all_inputs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">tensor_util</span><span class="o">.</span><span class="n">is_tensor</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">all_inputs</span><span class="p">):</span>
          <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">tensor_util</span><span class="o">.</span><span class="n">is_tensor</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">all_inputs</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Do not pass inputs that mix Numpy arrays and &#39;</span>
                             <span class="s1">&#39;TensorFlow tensors. &#39;</span>
                             <span class="s1">&#39;You passed: x=&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;; y=&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">context</span><span class="o">.</span><span class="n">executing_eagerly</span><span class="p">():</span>
          <span class="n">target_tensors</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
          <span class="c1"># Handle target tensors if any passed.</span>
          <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="n">y</span> <span class="o">=</span> <span class="p">[</span><span class="n">y</span><span class="p">]</span>
          <span class="n">target_tensors</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">y</span> <span class="k">if</span> <span class="n">tensor_util</span><span class="o">.</span><span class="n">is_tensor</span><span class="p">(</span><span class="n">v</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">optimizer</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">optimizer</span><span class="p">,</span>
                     <span class="n">loss</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">loss</span><span class="p">,</span>
                     <span class="n">metrics</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">metrics</span><span class="p">,</span>
                     <span class="n">loss_weights</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">loss_weights</span><span class="p">,</span>
                     <span class="n">target_tensors</span><span class="o">=</span><span class="n">target_tensors</span><span class="p">)</span>

    <span class="c1"># If `x` and `y` were all symbolic, then no model should not be fed any</span>
    <span class="c1"># inputs and targets.</span>
    <span class="c1"># Note: in this case, `any` and `all` are equivalent since we disallow</span>
    <span class="c1"># mixed symbolic/value inputs.</span>
    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">tensor_util</span><span class="o">.</span><span class="n">is_tensor</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">all_inputs</span><span class="p">):</span>
      <span class="k">return</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>

    <span class="c1"># What follows is input validation and standardization to list format,</span>
    <span class="c1"># in the case where all inputs are value arrays.</span>

    <span class="k">if</span> <span class="n">context</span><span class="o">.</span><span class="n">executing_eagerly</span><span class="p">():</span>
      <span class="c1"># In eager mode, do not do shape validation.</span>
      <span class="n">feed_input_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_names</span>
      <span class="n">feed_input_shapes</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">elif</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_graph_network</span><span class="p">:</span>
      <span class="c1"># Case: symbolic-mode subclassed network. Do not do shape validation.</span>
      <span class="n">feed_input_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_feed_input_names</span>
      <span class="n">feed_input_shapes</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="c1"># Case: symbolic-mode graph network.</span>
      <span class="c1"># In this case, we run extensive shape validation checks.</span>
      <span class="n">feed_input_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_feed_input_names</span>
      <span class="n">feed_input_shapes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_feed_input_shapes</span>

    <span class="c1"># Standardize the inputs.</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">training_utils</span><span class="o">.</span><span class="n">standardize_input_data</span><span class="p">(</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">feed_input_names</span><span class="p">,</span>
        <span class="n">feed_input_shapes</span><span class="p">,</span>
        <span class="n">check_batch_axis</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>  <span class="c1"># Don&#39;t enforce the batch size.</span>
        <span class="n">exception_prefix</span><span class="o">=</span><span class="s1">&#39;input&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">y</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
      <span class="k">if</span> <span class="n">context</span><span class="o">.</span><span class="n">executing_eagerly</span><span class="p">():</span>
        <span class="n">feed_output_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_names</span>
        <span class="n">feed_output_shapes</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># Sample weighting not supported in this case.</span>
        <span class="c1"># TODO(fchollet): consider supporting it.</span>
        <span class="n">feed_sample_weight_modes</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">outputs</span><span class="p">]</span>
      <span class="k">elif</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_graph_network</span><span class="p">:</span>
        <span class="n">feed_output_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_feed_output_names</span>
        <span class="n">feed_output_shapes</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># Sample weighting not supported in this case.</span>
        <span class="c1"># TODO(fchollet): consider supporting it.</span>
        <span class="n">feed_sample_weight_modes</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">outputs</span><span class="p">]</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="n">feed_output_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_feed_output_names</span>
        <span class="n">feed_sample_weight_modes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_feed_sample_weight_modes</span>
        <span class="n">feed_output_shapes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">output_shape</span><span class="p">,</span> <span class="n">loss_fn</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_feed_output_shapes</span><span class="p">,</span>
                                         <span class="bp">self</span><span class="o">.</span><span class="n">_feed_loss_fns</span><span class="p">):</span>
          <span class="k">if</span> <span class="n">loss_fn</span> <span class="ow">is</span> <span class="n">losses</span><span class="o">.</span><span class="n">sparse_categorical_crossentropy</span><span class="p">:</span>
            <span class="n">feed_output_shapes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">output_shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="p">,))</span>
          <span class="k">elif</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">loss_fn</span><span class="p">,</span> <span class="s1">&#39;__name__&#39;</span><span class="p">)</span> <span class="ow">or</span>
                <span class="nb">getattr</span><span class="p">(</span><span class="n">losses</span><span class="p">,</span> <span class="n">loss_fn</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="c1"># If `loss_fn` is not a function (e.g. callable class)</span>
            <span class="c1"># or if it not in the `losses` module, then</span>
            <span class="c1"># it is a user-defined loss and we make no assumptions</span>
            <span class="c1"># about it.</span>
            <span class="n">feed_output_shapes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
          <span class="k">else</span><span class="p">:</span>
            <span class="n">feed_output_shapes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">output_shape</span><span class="p">)</span>

      <span class="c1"># Standardize the outputs.</span>
      <span class="n">y</span> <span class="o">=</span> <span class="n">training_utils</span><span class="o">.</span><span class="n">standardize_input_data</span><span class="p">(</span>
          <span class="n">y</span><span class="p">,</span>
          <span class="n">feed_output_names</span><span class="p">,</span>
          <span class="n">feed_output_shapes</span><span class="p">,</span>
          <span class="n">check_batch_axis</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>  <span class="c1"># Don&#39;t enforce the batch size.</span>
          <span class="n">exception_prefix</span><span class="o">=</span><span class="s1">&#39;target&#39;</span><span class="p">)</span>

      <span class="c1"># Generate sample-wise weight values given the `sample_weight` and</span>
      <span class="c1"># `class_weight` arguments.</span>
      <span class="n">sample_weights</span> <span class="o">=</span> <span class="n">training_utils</span><span class="o">.</span><span class="n">standardize_sample_weights</span><span class="p">(</span>
          <span class="n">sample_weight</span><span class="p">,</span> <span class="n">feed_output_names</span><span class="p">)</span>
      <span class="n">class_weights</span> <span class="o">=</span> <span class="n">training_utils</span><span class="o">.</span><span class="n">standardize_class_weights</span><span class="p">(</span>
          <span class="n">class_weight</span><span class="p">,</span> <span class="n">feed_output_names</span><span class="p">)</span>
      <span class="n">sample_weights</span> <span class="o">=</span> <span class="p">[</span>
          <span class="n">training_utils</span><span class="o">.</span><span class="n">standardize_weights</span><span class="p">(</span><span class="n">ref</span><span class="p">,</span> <span class="n">sw</span><span class="p">,</span> <span class="n">cw</span><span class="p">,</span> <span class="n">mode</span><span class="p">)</span>
          <span class="k">for</span> <span class="p">(</span><span class="n">ref</span><span class="p">,</span> <span class="n">sw</span><span class="p">,</span> <span class="n">cw</span><span class="p">,</span> <span class="n">mode</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">sample_weights</span><span class="p">,</span> <span class="n">class_weights</span><span class="p">,</span>
                                         <span class="n">feed_sample_weight_modes</span><span class="p">)</span>
      <span class="p">]</span>
      <span class="c1"># Check that all arrays have the same length.</span>
      <span class="n">training_utils</span><span class="o">.</span><span class="n">check_array_lengths</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">sample_weights</span><span class="p">)</span>
      <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_graph_network</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">context</span><span class="o">.</span><span class="n">executing_eagerly</span><span class="p">():</span>
        <span class="c1"># Additional checks to avoid users mistakenly using improper loss fns.</span>
        <span class="n">training_utils</span><span class="o">.</span><span class="n">check_loss_and_target_compatibility</span><span class="p">(</span>
            <span class="n">y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_feed_loss_fns</span><span class="p">,</span> <span class="n">feed_output_shapes</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">y</span> <span class="o">=</span> <span class="p">[]</span>
      <span class="n">sample_weights</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">stateful</span> <span class="ow">and</span> <span class="n">batch_size</span><span class="p">:</span>
      <span class="c1"># Check that for stateful networks, number of samples is a multiple</span>
      <span class="c1"># of the static batch size.</span>
      <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">%</span> <span class="n">batch_size</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;In a stateful network, &#39;</span>
                         <span class="s1">&#39;you should only pass inputs with &#39;</span>
                         <span class="s1">&#39;a number of samples that can be &#39;</span>
                         <span class="s1">&#39;divided by the batch size. Found: &#39;</span> <span class="o">+</span>
                         <span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="s1">&#39; samples&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">sample_weights</span>

  <span class="k">def</span> <span class="nf">_set_inputs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inputs</span><span class="p">,</span> <span class="n">training</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Set model&#39;s input and output specs based on the input data received.</span>

<span class="sd">    This is to be used for Model subclasses, which do not know at instantiation</span>
<span class="sd">    time what their inputs look like.</span>

<span class="sd">    Args:</span>
<span class="sd">      inputs: Single array, or list of arrays. The arrays could be placeholders,</span>
<span class="sd">        Numpy arrays, or data tensors.</span>
<span class="sd">        - if placeholders: the model is built on top of these placeholders,</span>
<span class="sd">          and we expect Numpy data to be fed for them when calling `fit`/etc.</span>
<span class="sd">        - if Numpy data: we create placeholders matching the shape of the Numpy</span>
<span class="sd">          arrays. We expect Numpy data to be fed for these placeholders</span>
<span class="sd">          when calling `fit`/etc.</span>
<span class="sd">        - if data tensors: the model is built on top of these tensors.</span>
<span class="sd">          We do not expect any Numpy data to be provided when calling `fit`/etc.</span>
<span class="sd">      training: Boolean or None. Only relevant in symbolic mode. Specifies</span>
<span class="sd">        whether to build the model&#39;s graph in inference mode (False), training</span>
<span class="sd">        mode (True), or using the Keras learning phase (None).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_uses_inputs_arg&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">):</span>
      <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
          <span class="s1">&#39;Subclassed Models without &quot;inputs&quot; in their call() signatures do &#39;</span>
          <span class="s1">&#39;not yet support shape inference. File a feature request if this &#39;</span>
          <span class="s1">&#39;limitation bothers you.&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;Sequential&#39;</span><span class="p">:</span>
      <span class="c1"># Note: we can&#39;t test whether the model is `Sequential` via `isinstance`</span>
      <span class="c1"># since `Sequential` depends on `Model`.</span>
      <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
        <span class="n">inputs</span> <span class="o">=</span> <span class="n">inputs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">input_shape</span><span class="o">=</span><span class="p">(</span><span class="kc">None</span><span class="p">,)</span> <span class="o">+</span> <span class="n">inputs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
    <span class="k">elif</span> <span class="n">context</span><span class="o">.</span><span class="n">executing_eagerly</span><span class="p">():</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">_eager_set_inputs</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">_symbolic_set_inputs</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">training</span><span class="o">=</span><span class="n">training</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">_set_scope</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scope</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Modify the Layer scope creation logic to create ResourceVariables.&quot;&quot;&quot;</span>
    <span class="nb">super</span><span class="p">(</span><span class="n">Model</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_set_scope</span><span class="p">(</span><span class="n">scope</span><span class="o">=</span><span class="n">scope</span><span class="p">)</span>
    <span class="c1"># Subclassed Models create ResourceVariables by default. This makes it</span>
    <span class="c1"># easier to use Models in an eager/graph agnostic way (since eager execution</span>
    <span class="c1"># always uses ResourceVariables).</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_graph_network</span><span class="p">:</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">_scope</span><span class="o">.</span><span class="n">set_use_resource</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">_eager_set_inputs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inputs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Set model&#39;s input and output specs based on the input data received.</span>

<span class="sd">    This is to be used for Model subclasses, which do not know at instantiation</span>
<span class="sd">    time what their inputs look like.</span>

<span class="sd">    We assume the number and ndim of outputs</span>
<span class="sd">    does not change over different calls.</span>

<span class="sd">    Args:</span>
<span class="sd">      inputs: Argument `x` (input data) passed by the user upon first model use.</span>

<span class="sd">    Raises:</span>
<span class="sd">      ValueError: If the model&#39;s inputs are already set.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="n">context</span><span class="o">.</span><span class="n">executing_eagerly</span><span class="p">()</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Model inputs are already set.&#39;</span><span class="p">)</span>
    <span class="c1"># On-the-fly setting of model inputs/outputs as DeferredTensors,</span>
    <span class="c1"># to keep track of number of inputs and outputs and their ndim.</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
      <span class="n">dummy_output_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">call</span><span class="p">(</span>
          <span class="p">[</span><span class="n">ops</span><span class="o">.</span><span class="n">convert_to_tensor</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">K</span><span class="o">.</span><span class="n">floatx</span><span class="p">())</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">inputs</span><span class="p">])</span>
      <span class="n">dummy_input_values</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">dummy_output_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">call</span><span class="p">(</span>
          <span class="n">ops</span><span class="o">.</span><span class="n">convert_to_tensor</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">K</span><span class="o">.</span><span class="n">floatx</span><span class="p">()))</span>
      <span class="n">dummy_input_values</span> <span class="o">=</span> <span class="p">[</span><span class="n">inputs</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dummy_output_values</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
      <span class="n">dummy_output_values</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">dummy_output_values</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">dummy_output_values</span> <span class="o">=</span> <span class="p">[</span><span class="n">dummy_output_values</span><span class="p">]</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">outputs</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">_DeferredTensor</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="kc">None</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">v</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span>
                        <span class="n">dtype</span><span class="o">=</span><span class="n">v</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">dummy_output_values</span><span class="p">]</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">_DeferredTensor</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="kc">None</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">v</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span>
                        <span class="n">dtype</span><span class="o">=</span><span class="n">v</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">dummy_input_values</span><span class="p">]</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">input_names</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s1">&#39;input_</span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dummy_input_values</span><span class="p">))]</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">output_names</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s1">&#39;output_</span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dummy_output_values</span><span class="p">))]</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">built</span> <span class="o">=</span> <span class="kc">True</span>

  <span class="k">def</span> <span class="nf">_symbolic_set_inputs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inputs</span><span class="p">,</span> <span class="n">outputs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">training</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Set model&#39;s inputs and output specs based.</span>

<span class="sd">    This is to be used for Model subclasses, which do not know at instantiation</span>
<span class="sd">    time what their inputs look like.</span>

<span class="sd">    Args:</span>
<span class="sd">      inputs: Argument `x` (input data) passed by the user upon first model use.</span>
<span class="sd">      outputs: None, a data tensor, or a list of data tensors. If None, the</span>
<span class="sd">        outputs will be determined by invoking self.call(), otherwise the</span>
<span class="sd">        provided value will be used.</span>
<span class="sd">      training: Boolean or None. Only relevant in symbolic mode. Specifies</span>
<span class="sd">        whether to build the model&#39;s graph in inference mode (False), training</span>
<span class="sd">        mode (True), or using the Keras learning phase (None).</span>

<span class="sd">    Raises:</span>
<span class="sd">      ValueError: If the model&#39;s inputs are already set.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="ow">not</span> <span class="n">context</span><span class="o">.</span><span class="n">executing_eagerly</span><span class="p">()</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Model inputs are already set.&#39;</span><span class="p">)</span>

    <span class="c1"># On-the-fly setting of symbolic model inputs (either by using the tensor</span>
    <span class="c1"># provided, or by creating a placeholder if Numpy data was provided).</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">input_names</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_feed_inputs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_feed_input_names</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_feed_input_shapes</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
      <span class="n">inputs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">inputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">inputs</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">inputs</span><span class="p">):</span>
      <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;input_</span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">input_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
      <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
          <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
      <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
        <span class="c1"># We fix the placeholder shape except the batch size.</span>
        <span class="c1"># This is suboptimal, but it is the best we can do with the info</span>
        <span class="c1"># we have. The user should call `model._set_inputs(placeholders)`</span>
        <span class="c1"># to specify custom placeholders if the need arises.</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="kc">None</span><span class="p">,)</span> <span class="o">+</span> <span class="n">v</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="n">placeholder</span> <span class="o">=</span> <span class="n">K</span><span class="o">.</span><span class="n">placeholder</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">placeholder</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_feed_inputs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">placeholder</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_feed_input_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_feed_input_shapes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Assumed tensor - TODO(fchollet) additional type check?</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">K</span><span class="o">.</span><span class="n">is_placeholder</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
          <span class="bp">self</span><span class="o">.</span><span class="n">_feed_inputs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
          <span class="bp">self</span><span class="o">.</span><span class="n">_feed_input_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
          <span class="bp">self</span><span class="o">.</span><span class="n">_feed_input_shapes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">K</span><span class="o">.</span><span class="n">int_shape</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">outputs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
      <span class="c1"># Obtain symbolic outputs by calling the model.</span>
      <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_expects_training_arg</span><span class="p">:</span>
          <span class="n">outputs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">training</span><span class="o">=</span><span class="n">training</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
          <span class="n">outputs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_expects_training_arg</span><span class="p">:</span>
          <span class="n">outputs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">,</span> <span class="n">training</span><span class="o">=</span><span class="n">training</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
          <span class="n">outputs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">outputs</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
      <span class="n">outputs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">outputs</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">outputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">outputs</span><span class="p">]</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">outputs</span> <span class="o">=</span> <span class="n">outputs</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">output_names</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s1">&#39;output_</span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outputs</span><span class="p">))]</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">built</span> <span class="o">=</span> <span class="kc">True</span>

<div class="viewcode-block" id="Model.fit"><a class="viewcode-back" href="../zf.html#zf.Model.fit">[docs]</a>  <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
          <span class="n">x</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
          <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
          <span class="n">batch_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
          <span class="n">epochs</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
          <span class="n">verbose</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
          <span class="n">callbacks</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
          <span class="n">validation_split</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span>
          <span class="n">validation_data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
          <span class="n">shuffle</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
          <span class="n">class_weight</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
          <span class="n">sample_weight</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
          <span class="n">initial_epoch</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
          <span class="n">steps_per_epoch</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
          <span class="n">validation_steps</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
          <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Trains the model for a fixed number of epochs (iterations on a dataset).</span>

<span class="sd">    Arguments:</span>
<span class="sd">        x: Numpy array of training data (if the model has a single input),</span>
<span class="sd">            or list of Numpy arrays (if the model has multiple inputs).</span>
<span class="sd">            If input layers in the model are named, you can also pass a</span>
<span class="sd">            dictionary mapping input names to Numpy arrays.</span>
<span class="sd">            `x` can be `None` (default) if feeding from</span>
<span class="sd">            TensorFlow data tensors.</span>
<span class="sd">        y: Numpy array of target (label) data</span>
<span class="sd">            (if the model has a single output),</span>
<span class="sd">            or list of Numpy arrays (if the model has multiple outputs).</span>
<span class="sd">            If output layers in the model are named, you can also pass a</span>
<span class="sd">            dictionary mapping output names to Numpy arrays.</span>
<span class="sd">            `y` can be `None` (default) if feeding from</span>
<span class="sd">            TensorFlow data tensors.</span>
<span class="sd">        batch_size: Integer or `None`.</span>
<span class="sd">            Number of samples per gradient update.</span>
<span class="sd">            If unspecified, `batch_size` will default to 32.</span>
<span class="sd">        epochs: Integer. Number of epochs to train the model.</span>
<span class="sd">            An epoch is an iteration over the entire `x` and `y`</span>
<span class="sd">            data provided.</span>
<span class="sd">            Note that in conjunction with `initial_epoch`,</span>
<span class="sd">            `epochs` is to be understood as &quot;final epoch&quot;.</span>
<span class="sd">            The model is not trained for a number of iterations</span>
<span class="sd">            given by `epochs`, but merely until the epoch</span>
<span class="sd">            of index `epochs` is reached.</span>
<span class="sd">        verbose: Integer. 0, 1, or 2. Verbosity mode.</span>
<span class="sd">            0 = silent, 1 = progress bar, 2 = one line per epoch.</span>
<span class="sd">        callbacks: List of `keras.callbacks.Callback` instances.</span>
<span class="sd">            List of callbacks to apply during training.</span>
<span class="sd">            See [callbacks](/callbacks).</span>
<span class="sd">        validation_split: Float between 0 and 1.</span>
<span class="sd">            Fraction of the training data to be used as validation data.</span>
<span class="sd">            The model will set apart this fraction of the training data,</span>
<span class="sd">            will not train on it, and will evaluate</span>
<span class="sd">            the loss and any model metrics</span>
<span class="sd">            on this data at the end of each epoch.</span>
<span class="sd">            The validation data is selected from the last samples</span>
<span class="sd">            in the `x` and `y` data provided, before shuffling.</span>
<span class="sd">        validation_data: tuple `(x_val, y_val)` or tuple</span>
<span class="sd">            `(x_val, y_val, val_sample_weights)` on which to evaluate</span>
<span class="sd">            the loss and any model metrics at the end of each epoch.</span>
<span class="sd">            The model will not be trained on this data.</span>
<span class="sd">            `validation_data` will override `validation_split`.</span>
<span class="sd">        shuffle: Boolean (whether to shuffle the training data</span>
<span class="sd">            before each epoch) or str (for &#39;batch&#39;).</span>
<span class="sd">            &#39;batch&#39; is a special option for dealing with the</span>
<span class="sd">            limitations of HDF5 data; it shuffles in batch-sized chunks.</span>
<span class="sd">            Has no effect when `steps_per_epoch` is not `None`.</span>
<span class="sd">        class_weight: Optional dictionary mapping class indices (integers)</span>
<span class="sd">            to a weight (float) value, used for weighting the loss function</span>
<span class="sd">            (during training only).</span>
<span class="sd">            This can be useful to tell the model to</span>
<span class="sd">            &quot;pay more attention&quot; to samples from</span>
<span class="sd">            an under-represented class.</span>
<span class="sd">        sample_weight: Optional Numpy array of weights for</span>
<span class="sd">            the training samples, used for weighting the loss function</span>
<span class="sd">            (during training only). You can either pass a flat (1D)</span>
<span class="sd">            Numpy array with the same length as the input samples</span>
<span class="sd">            (1:1 mapping between weights and samples),</span>
<span class="sd">            or in the case of temporal data,</span>
<span class="sd">            you can pass a 2D array with shape</span>
<span class="sd">            `(samples, sequence_length)`,</span>
<span class="sd">            to apply a different weight to every timestep of every sample.</span>
<span class="sd">            In this case you should make sure to specify</span>
<span class="sd">            `sample_weight_mode=&quot;temporal&quot;` in `compile()`.</span>
<span class="sd">        initial_epoch: Integer.</span>
<span class="sd">            Epoch at which to start training</span>
<span class="sd">            (useful for resuming a previous training run).</span>
<span class="sd">        steps_per_epoch: Integer or `None`.</span>
<span class="sd">            Total number of steps (batches of samples)</span>
<span class="sd">            before declaring one epoch finished and starting the</span>
<span class="sd">            next epoch. When training with input tensors such as</span>
<span class="sd">            TensorFlow data tensors, the default `None` is equal to</span>
<span class="sd">            the number of samples in your dataset divided by</span>
<span class="sd">            the batch size, or 1 if that cannot be determined.</span>
<span class="sd">        validation_steps: Only relevant if `steps_per_epoch`</span>
<span class="sd">            is specified. Total number of steps (batches of samples)</span>
<span class="sd">            to validate before stopping.</span>
<span class="sd">        **kwargs: Used for backwards compatibility.</span>

<span class="sd">    Returns:</span>
<span class="sd">        A `History` object. Its `History.history` attribute is</span>
<span class="sd">        a record of training loss values and metrics values</span>
<span class="sd">        at successive epochs, as well as validation loss values</span>
<span class="sd">        and validation metrics values (if applicable).</span>

<span class="sd">    Raises:</span>
<span class="sd">        RuntimeError: If the model was never compiled.</span>
<span class="sd">        ValueError: In case of mismatch between the provided input data</span>
<span class="sd">            and what the model expects.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># TODO(fchollet): this method may be creating reference cycles, which would</span>
    <span class="c1"># lead to accumulating garbage in memory when called in a loop. Investigate.</span>

    <span class="c1"># Backwards compatibility</span>
    <span class="k">if</span> <span class="n">batch_size</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">steps_per_epoch</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
      <span class="n">batch_size</span> <span class="o">=</span> <span class="mi">32</span>
    <span class="c1"># Legacy support</span>
    <span class="k">if</span> <span class="s1">&#39;nb_epoch&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
      <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
          <span class="s1">&#39;The `nb_epoch` argument in `fit` &#39;</span>
          <span class="s1">&#39;has been renamed `epochs`.&#39;</span><span class="p">)</span>
      <span class="n">epochs</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;nb_epoch&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">kwargs</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Unrecognized keyword arguments: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">kwargs</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">y</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">steps_per_epoch</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;If fitting from data tensors, &#39;</span>
                       <span class="s1">&#39;you should specify the `steps_per_epoch` &#39;</span>
                       <span class="s1">&#39;argument.&#39;</span><span class="p">)</span>

    <span class="c1"># Validate user data.</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">sample_weights</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_standardize_user_data</span><span class="p">(</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">y</span><span class="p">,</span>
        <span class="n">sample_weight</span><span class="o">=</span><span class="n">sample_weight</span><span class="p">,</span>
        <span class="n">class_weight</span><span class="o">=</span><span class="n">class_weight</span><span class="p">,</span>
        <span class="n">batch_size</span><span class="o">=</span><span class="n">batch_size</span><span class="p">)</span>
    <span class="c1"># Prepare validation data.</span>
    <span class="k">if</span> <span class="n">validation_data</span><span class="p">:</span>
      <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">validation_data</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">val_x</span><span class="p">,</span> <span class="n">val_y</span> <span class="o">=</span> <span class="n">validation_data</span>  <span class="c1"># pylint: disable=unpacking-non-sequence</span>
        <span class="n">val_sample_weight</span> <span class="o">=</span> <span class="kc">None</span>
      <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">validation_data</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">val_x</span><span class="p">,</span> <span class="n">val_y</span><span class="p">,</span> <span class="n">val_sample_weight</span> <span class="o">=</span> <span class="n">validation_data</span>  <span class="c1"># pylint: disable=unpacking-non-sequence</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s1">&#39;When passing validation_data, &#39;</span>
            <span class="s1">&#39;it must contain 2 (x_val, y_val) &#39;</span>
            <span class="s1">&#39;or 3 (x_val, y_val, val_sample_weights) &#39;</span>
            <span class="s1">&#39;items, however it contains </span><span class="si">%d</span><span class="s1"> items&#39;</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">validation_data</span><span class="p">))</span>

      <span class="n">val_x</span><span class="p">,</span> <span class="n">val_y</span><span class="p">,</span> <span class="n">val_sample_weights</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_standardize_user_data</span><span class="p">(</span>
          <span class="n">val_x</span><span class="p">,</span>
          <span class="n">val_y</span><span class="p">,</span>
          <span class="n">sample_weight</span><span class="o">=</span><span class="n">val_sample_weight</span><span class="p">,</span>
          <span class="n">batch_size</span><span class="o">=</span><span class="n">batch_size</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">validation_split</span> <span class="ow">and</span> <span class="mf">0.</span> <span class="o">&lt;</span> <span class="n">validation_split</span> <span class="o">&lt;</span> <span class="mf">1.</span><span class="p">:</span>
      <span class="k">if</span> <span class="n">training_utils</span><span class="o">.</span><span class="n">has_symbolic_tensors</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;If your data is in the form of symbolic tensors, &#39;</span>
                         <span class="s1">&#39;you cannot use `validation_split`.&#39;</span><span class="p">)</span>
      <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;shape&#39;</span><span class="p">):</span>
        <span class="n">split_at</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.</span> <span class="o">-</span> <span class="n">validation_split</span><span class="p">))</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="n">split_at</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.</span> <span class="o">-</span> <span class="n">validation_split</span><span class="p">))</span>
      <span class="n">x</span><span class="p">,</span> <span class="n">val_x</span> <span class="o">=</span> <span class="p">(</span><span class="n">slice_arrays</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">split_at</span><span class="p">),</span> <span class="n">slice_arrays</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">split_at</span><span class="p">))</span>
      <span class="n">y</span><span class="p">,</span> <span class="n">val_y</span> <span class="o">=</span> <span class="p">(</span><span class="n">slice_arrays</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">split_at</span><span class="p">),</span> <span class="n">slice_arrays</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">split_at</span><span class="p">))</span>
      <span class="n">sample_weights</span><span class="p">,</span> <span class="n">val_sample_weights</span> <span class="o">=</span> <span class="p">(</span><span class="n">slice_arrays</span><span class="p">(</span>
          <span class="n">sample_weights</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">split_at</span><span class="p">),</span> <span class="n">slice_arrays</span><span class="p">(</span><span class="n">sample_weights</span><span class="p">,</span> <span class="n">split_at</span><span class="p">))</span>
    <span class="k">elif</span> <span class="n">validation_steps</span><span class="p">:</span>
      <span class="n">val_x</span> <span class="o">=</span> <span class="p">[]</span>
      <span class="n">val_y</span> <span class="o">=</span> <span class="p">[]</span>
      <span class="n">val_sample_weights</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">val_x</span> <span class="o">=</span> <span class="kc">None</span>
      <span class="n">val_y</span> <span class="o">=</span> <span class="kc">None</span>
      <span class="n">val_sample_weights</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">if</span> <span class="n">context</span><span class="o">.</span><span class="n">executing_eagerly</span><span class="p">():</span>
      <span class="k">return</span> <span class="n">training_eager</span><span class="o">.</span><span class="n">fit_loop</span><span class="p">(</span>
          <span class="bp">self</span><span class="p">,</span>
          <span class="n">inputs</span><span class="o">=</span><span class="n">x</span><span class="p">,</span>
          <span class="n">targets</span><span class="o">=</span><span class="n">y</span><span class="p">,</span>
          <span class="n">sample_weights</span><span class="o">=</span><span class="n">sample_weights</span><span class="p">,</span>
          <span class="n">batch_size</span><span class="o">=</span><span class="n">batch_size</span><span class="p">,</span>
          <span class="n">epochs</span><span class="o">=</span><span class="n">epochs</span><span class="p">,</span>
          <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
          <span class="n">callbacks</span><span class="o">=</span><span class="n">callbacks</span><span class="p">,</span>
          <span class="n">val_inputs</span><span class="o">=</span><span class="n">val_x</span><span class="p">,</span>
          <span class="n">val_targets</span><span class="o">=</span><span class="n">val_y</span><span class="p">,</span>
          <span class="n">val_sample_weights</span><span class="o">=</span><span class="n">val_sample_weights</span><span class="p">,</span>
          <span class="n">shuffle</span><span class="o">=</span><span class="n">shuffle</span><span class="p">,</span>
          <span class="n">initial_epoch</span><span class="o">=</span><span class="n">initial_epoch</span><span class="p">,</span>
          <span class="n">steps_per_epoch</span><span class="o">=</span><span class="n">steps_per_epoch</span><span class="p">,</span>
          <span class="n">validation_steps</span><span class="o">=</span><span class="n">validation_steps</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">training_arrays</span><span class="o">.</span><span class="n">fit_loop</span><span class="p">(</span>
          <span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span>
          <span class="n">sample_weights</span><span class="o">=</span><span class="n">sample_weights</span><span class="p">,</span>
          <span class="n">batch_size</span><span class="o">=</span><span class="n">batch_size</span><span class="p">,</span>
          <span class="n">epochs</span><span class="o">=</span><span class="n">epochs</span><span class="p">,</span>
          <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
          <span class="n">callbacks</span><span class="o">=</span><span class="n">callbacks</span><span class="p">,</span>
          <span class="n">val_inputs</span><span class="o">=</span><span class="n">val_x</span><span class="p">,</span>
          <span class="n">val_targets</span><span class="o">=</span><span class="n">val_y</span><span class="p">,</span>
          <span class="n">val_sample_weights</span><span class="o">=</span><span class="n">val_sample_weights</span><span class="p">,</span>
          <span class="n">shuffle</span><span class="o">=</span><span class="n">shuffle</span><span class="p">,</span>
          <span class="n">initial_epoch</span><span class="o">=</span><span class="n">initial_epoch</span><span class="p">,</span>
          <span class="n">steps_per_epoch</span><span class="o">=</span><span class="n">steps_per_epoch</span><span class="p">,</span>
          <span class="n">validation_steps</span><span class="o">=</span><span class="n">validation_steps</span><span class="p">)</span></div>

<div class="viewcode-block" id="Model.evaluate"><a class="viewcode-back" href="../zf.html#zf.Model.evaluate">[docs]</a>  <span class="k">def</span> <span class="nf">evaluate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
               <span class="n">x</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="n">batch_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="n">verbose</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
               <span class="n">sample_weight</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="n">steps</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns the loss value &amp; metrics values for the model in test mode.</span>

<span class="sd">    Computation is done in batches.</span>

<span class="sd">    Arguments:</span>
<span class="sd">        x: Numpy array of test data (if the model has a single input),</span>
<span class="sd">            or list of Numpy arrays (if the model has multiple inputs).</span>
<span class="sd">            If input layers in the model are named, you can also pass a</span>
<span class="sd">            dictionary mapping input names to Numpy arrays.</span>
<span class="sd">            `x` can be `None` (default) if feeding from</span>
<span class="sd">            TensorFlow data tensors.</span>
<span class="sd">        y: Numpy array of target (label) data</span>
<span class="sd">            (if the model has a single output),</span>
<span class="sd">            or list of Numpy arrays (if the model has multiple outputs).</span>
<span class="sd">            If output layers in the model are named, you can also pass a</span>
<span class="sd">            dictionary mapping output names to Numpy arrays.</span>
<span class="sd">            `y` can be `None` (default) if feeding from</span>
<span class="sd">            TensorFlow data tensors.</span>
<span class="sd">        batch_size: Integer or `None`.</span>
<span class="sd">            Number of samples per evaluation step.</span>
<span class="sd">            If unspecified, `batch_size` will default to 32.</span>
<span class="sd">        verbose: 0 or 1. Verbosity mode.</span>
<span class="sd">            0 = silent, 1 = progress bar.</span>
<span class="sd">        sample_weight: Optional Numpy array of weights for</span>
<span class="sd">            the test samples, used for weighting the loss function.</span>
<span class="sd">            You can either pass a flat (1D)</span>
<span class="sd">            Numpy array with the same length as the input samples</span>
<span class="sd">            (1:1 mapping between weights and samples),</span>
<span class="sd">            or in the case of temporal data,</span>
<span class="sd">            you can pass a 2D array with shape</span>
<span class="sd">            `(samples, sequence_length)`,</span>
<span class="sd">            to apply a different weight to every timestep of every sample.</span>
<span class="sd">            In this case you should make sure to specify</span>
<span class="sd">            `sample_weight_mode=&quot;temporal&quot;` in `compile()`.</span>
<span class="sd">        steps: Integer or `None`.</span>
<span class="sd">            Total number of steps (batches of samples)</span>
<span class="sd">            before declaring the evaluation round finished.</span>
<span class="sd">            Ignored with the default value of `None`.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Scalar test loss (if the model has a single output and no metrics)</span>
<span class="sd">        or list of scalars (if the model has multiple outputs</span>
<span class="sd">        and/or metrics). The attribute `model.metrics_names` will give you</span>
<span class="sd">        the display labels for the scalar outputs.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: in case of invalid arguments.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Backwards compatibility.</span>
    <span class="k">if</span> <span class="n">batch_size</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">steps</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
      <span class="n">batch_size</span> <span class="o">=</span> <span class="mi">32</span>
    <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">y</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">steps</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;If evaluating from data tensors, &#39;</span>
                       <span class="s1">&#39;you should specify the `steps` &#39;</span>
                       <span class="s1">&#39;argument.&#39;</span><span class="p">)</span>

    <span class="c1"># Validate user data.</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">sample_weights</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_standardize_user_data</span><span class="p">(</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">y</span><span class="p">,</span>
        <span class="n">sample_weight</span><span class="o">=</span><span class="n">sample_weight</span><span class="p">,</span>
        <span class="n">batch_size</span><span class="o">=</span><span class="n">batch_size</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">context</span><span class="o">.</span><span class="n">executing_eagerly</span><span class="p">():</span>
      <span class="k">return</span> <span class="n">training_eager</span><span class="o">.</span><span class="n">test_loop</span><span class="p">(</span>
          <span class="bp">self</span><span class="p">,</span> <span class="n">inputs</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">targets</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">sample_weights</span><span class="o">=</span><span class="n">sample_weights</span><span class="p">,</span>
          <span class="n">batch_size</span><span class="o">=</span><span class="n">batch_size</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span> <span class="n">steps</span><span class="o">=</span><span class="n">steps</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">training_arrays</span><span class="o">.</span><span class="n">test_loop</span><span class="p">(</span>
          <span class="bp">self</span><span class="p">,</span> <span class="n">inputs</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">targets</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">sample_weights</span><span class="o">=</span><span class="n">sample_weights</span><span class="p">,</span>
          <span class="n">batch_size</span><span class="o">=</span><span class="n">batch_size</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span> <span class="n">steps</span><span class="o">=</span><span class="n">steps</span><span class="p">)</span></div>

<div class="viewcode-block" id="Model.predict"><a class="viewcode-back" href="../zf.html#zf.Model.predict">[docs]</a>  <span class="k">def</span> <span class="nf">predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">steps</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Generates output predictions for the input samples.</span>

<span class="sd">    Computation is done in batches.</span>

<span class="sd">    Arguments:</span>
<span class="sd">        x: The input data, as a Numpy array</span>
<span class="sd">            (or list of Numpy arrays if the model has multiple outputs).</span>
<span class="sd">        batch_size: Integer. If unspecified, it will default to 32.</span>
<span class="sd">        verbose: Verbosity mode, 0 or 1.</span>
<span class="sd">        steps: Total number of steps (batches of samples)</span>
<span class="sd">            before declaring the prediction round finished.</span>
<span class="sd">            Ignored with the default value of `None`.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Numpy array(s) of predictions.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: In case of mismatch between the provided</span>
<span class="sd">            input data and the model&#39;s expectations,</span>
<span class="sd">            or in case a stateful model receives a number of samples</span>
<span class="sd">            that is not a multiple of the batch size.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Backwards compatibility.</span>
    <span class="k">if</span> <span class="n">batch_size</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">steps</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
      <span class="n">batch_size</span> <span class="o">=</span> <span class="mi">32</span>
    <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">steps</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;If predicting from data tensors, &#39;</span>
                       <span class="s1">&#39;you should specify the `steps` &#39;</span>
                       <span class="s1">&#39;argument.&#39;</span><span class="p">)</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_standardize_user_data</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">context</span><span class="o">.</span><span class="n">executing_eagerly</span><span class="p">():</span>
      <span class="k">return</span> <span class="n">training_eager</span><span class="o">.</span><span class="n">predict_loop</span><span class="p">(</span>
          <span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="n">batch_size</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span> <span class="n">steps</span><span class="o">=</span><span class="n">steps</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">training_arrays</span><span class="o">.</span><span class="n">predict_loop</span><span class="p">(</span>
          <span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="n">batch_size</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span> <span class="n">steps</span><span class="o">=</span><span class="n">steps</span><span class="p">)</span></div>

<div class="viewcode-block" id="Model.train_on_batch"><a class="viewcode-back" href="../zf.html#zf.Model.train_on_batch">[docs]</a>  <span class="k">def</span> <span class="nf">train_on_batch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">sample_weight</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">class_weight</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Runs a single gradient update on a single batch of data.</span>

<span class="sd">    Arguments:</span>
<span class="sd">        x: Numpy array of training data,</span>
<span class="sd">            or list of Numpy arrays if the model has multiple inputs.</span>
<span class="sd">            If all inputs in the model are named,</span>
<span class="sd">            you can also pass a dictionary</span>
<span class="sd">            mapping input names to Numpy arrays.</span>
<span class="sd">        y: Numpy array of target data,</span>
<span class="sd">            or list of Numpy arrays if the model has multiple outputs.</span>
<span class="sd">            If all outputs in the model are named,</span>
<span class="sd">            you can also pass a dictionary</span>
<span class="sd">            mapping output names to Numpy arrays.</span>
<span class="sd">        sample_weight: Optional array of the same length as x, containing</span>
<span class="sd">            weights to apply to the model&#39;s loss for each sample.</span>
<span class="sd">            In the case of temporal data, you can pass a 2D array</span>
<span class="sd">            with shape (samples, sequence_length),</span>
<span class="sd">            to apply a different weight to every timestep of every sample.</span>
<span class="sd">            In this case you should make sure to specify</span>
<span class="sd">            sample_weight_mode=&quot;temporal&quot; in compile().</span>
<span class="sd">        class_weight: Optional dictionary mapping</span>
<span class="sd">            class indices (integers) to</span>
<span class="sd">            a weight (float) to apply to the model&#39;s loss for the samples</span>
<span class="sd">            from this class during training.</span>
<span class="sd">            This can be useful to tell the model to &quot;pay more attention&quot; to</span>
<span class="sd">            samples from an under-represented class.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Scalar training loss</span>
<span class="sd">        (if the model has a single output and no metrics)</span>
<span class="sd">        or list of scalars (if the model has multiple outputs</span>
<span class="sd">        and/or metrics). The attribute `model.metrics_names` will give you</span>
<span class="sd">        the display labels for the scalar outputs.</span>

<span class="sd">    Raises:</span>
<span class="sd">      ValueError: In case of invalid user-provided arguments.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">sample_weights</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_standardize_user_data</span><span class="p">(</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">y</span><span class="p">,</span>
        <span class="n">sample_weight</span><span class="o">=</span><span class="n">sample_weight</span><span class="p">,</span>
        <span class="n">class_weight</span><span class="o">=</span><span class="n">class_weight</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">context</span><span class="o">.</span><span class="n">executing_eagerly</span><span class="p">():</span>
      <span class="n">outputs</span> <span class="o">=</span> <span class="n">training_eager</span><span class="o">.</span><span class="n">train_on_batch</span><span class="p">(</span>
          <span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">sample_weights</span><span class="o">=</span><span class="n">sample_weights</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">uses_learning_phase</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">K</span><span class="o">.</span><span class="n">learning_phase</span><span class="p">(),</span> <span class="nb">int</span><span class="p">):</span>
        <span class="n">ins</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">+</span> <span class="n">sample_weights</span> <span class="o">+</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="n">ins</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">+</span> <span class="n">sample_weights</span>

      <span class="bp">self</span><span class="o">.</span><span class="n">_make_train_function</span><span class="p">()</span>
      <span class="n">outputs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">train_function</span><span class="p">(</span><span class="n">ins</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">outputs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">outputs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">outputs</span></div>

<div class="viewcode-block" id="Model.test_on_batch"><a class="viewcode-back" href="../zf.html#zf.Model.test_on_batch">[docs]</a>  <span class="k">def</span> <span class="nf">test_on_batch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">sample_weight</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Test the model on a single batch of samples.</span>

<span class="sd">    Arguments:</span>
<span class="sd">        x: Numpy array of test data,</span>
<span class="sd">            or list of Numpy arrays if the model has multiple inputs.</span>
<span class="sd">            If all inputs in the model are named,</span>
<span class="sd">            you can also pass a dictionary</span>
<span class="sd">            mapping input names to Numpy arrays.</span>
<span class="sd">        y: Numpy array of target data,</span>
<span class="sd">            or list of Numpy arrays if the model has multiple outputs.</span>
<span class="sd">            If all outputs in the model are named,</span>
<span class="sd">            you can also pass a dictionary</span>
<span class="sd">            mapping output names to Numpy arrays.</span>
<span class="sd">        sample_weight: Optional array of the same length as x, containing</span>
<span class="sd">            weights to apply to the model&#39;s loss for each sample.</span>
<span class="sd">            In the case of temporal data, you can pass a 2D array</span>
<span class="sd">            with shape (samples, sequence_length),</span>
<span class="sd">            to apply a different weight to every timestep of every sample.</span>
<span class="sd">            In this case you should make sure to specify</span>
<span class="sd">            sample_weight_mode=&quot;temporal&quot; in compile().</span>

<span class="sd">    Returns:</span>
<span class="sd">        Scalar test loss (if the model has a single output and no metrics)</span>
<span class="sd">        or list of scalars (if the model has multiple outputs</span>
<span class="sd">        and/or metrics). The attribute `model.metrics_names` will give you</span>
<span class="sd">        the display labels for the scalar outputs.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: In case of invalid user-provided arguments.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">sample_weights</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_standardize_user_data</span><span class="p">(</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">sample_weight</span><span class="o">=</span><span class="n">sample_weight</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">context</span><span class="o">.</span><span class="n">executing_eagerly</span><span class="p">():</span>
      <span class="n">outputs</span> <span class="o">=</span> <span class="n">training_eager</span><span class="o">.</span><span class="n">test_on_batch</span><span class="p">(</span>
          <span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">sample_weights</span><span class="o">=</span><span class="n">sample_weights</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">uses_learning_phase</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">K</span><span class="o">.</span><span class="n">learning_phase</span><span class="p">(),</span> <span class="nb">int</span><span class="p">):</span>
        <span class="n">ins</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">+</span> <span class="n">sample_weights</span> <span class="o">+</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="n">ins</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">+</span> <span class="n">sample_weights</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">_make_test_function</span><span class="p">()</span>
      <span class="n">outputs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">test_function</span><span class="p">(</span><span class="n">ins</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">outputs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">outputs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">outputs</span></div>

<div class="viewcode-block" id="Model.predict_on_batch"><a class="viewcode-back" href="../zf.html#zf.Model.predict_on_batch">[docs]</a>  <span class="k">def</span> <span class="nf">predict_on_batch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns predictions for a single batch of samples.</span>

<span class="sd">    Arguments:</span>
<span class="sd">        x: Input samples, as a Numpy array.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Numpy array(s) of predictions.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_standardize_user_data</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">context</span><span class="o">.</span><span class="n">executing_eagerly</span><span class="p">():</span>
      <span class="n">inputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">ops</span><span class="o">.</span><span class="n">convert_to_tensor</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">K</span><span class="o">.</span><span class="n">floatx</span><span class="p">())</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">x</span><span class="p">]</span>
      <span class="k">return</span> <span class="bp">self</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span>  <span class="c1"># pylint: disable=not-callable</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">context</span><span class="o">.</span><span class="n">executing_eagerly</span><span class="p">():</span>
      <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">uses_learning_phase</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">K</span><span class="o">.</span><span class="n">learning_phase</span><span class="p">(),</span> <span class="nb">int</span><span class="p">):</span>
        <span class="n">ins</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="n">ins</span> <span class="o">=</span> <span class="n">x</span>

      <span class="bp">self</span><span class="o">.</span><span class="n">_make_predict_function</span><span class="p">()</span>
      <span class="n">outputs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">predict_function</span><span class="p">(</span><span class="n">ins</span><span class="p">)</span>

      <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">outputs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">outputs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
      <span class="k">return</span> <span class="n">outputs</span></div>

<div class="viewcode-block" id="Model.fit_generator"><a class="viewcode-back" href="../zf.html#zf.Model.fit_generator">[docs]</a>  <span class="k">def</span> <span class="nf">fit_generator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                    <span class="n">generator</span><span class="p">,</span>
                    <span class="n">steps_per_epoch</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">epochs</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                    <span class="n">verbose</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                    <span class="n">callbacks</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">validation_data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">validation_steps</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">class_weight</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">max_queue_size</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
                    <span class="n">workers</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                    <span class="n">use_multiprocessing</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">shuffle</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="n">initial_epoch</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Fits the model on data yielded batch-by-batch by a Python generator.</span>

<span class="sd">    The generator is run in parallel to the model, for efficiency.</span>
<span class="sd">    For instance, this allows you to do real-time data augmentation</span>
<span class="sd">    on images on CPU in parallel to training your model on GPU.</span>

<span class="sd">    The use of `keras.utils.Sequence` guarantees the ordering</span>
<span class="sd">    and guarantees the single use of every input per epoch when</span>
<span class="sd">    using `use_multiprocessing=True`.</span>

<span class="sd">    Arguments:</span>
<span class="sd">        generator: A generator or an instance of `Sequence`</span>
<span class="sd">          (`keras.utils.Sequence`)</span>
<span class="sd">            object in order to avoid duplicate data</span>
<span class="sd">            when using multiprocessing.</span>
<span class="sd">            The output of the generator must be either</span>
<span class="sd">            - a tuple `(inputs, targets)`</span>
<span class="sd">            - a tuple `(inputs, targets, sample_weights)`.</span>
<span class="sd">            This tuple (a single output of the generator) makes a single batch.</span>
<span class="sd">            Therefore, all arrays in this tuple must have the same length (equal</span>
<span class="sd">            to the size of this batch). Different batches may have different</span>
<span class="sd">              sizes.</span>
<span class="sd">            For example, the last batch of the epoch is commonly smaller than</span>
<span class="sd">              the</span>
<span class="sd">            others, if the size of the dataset is not divisible by the batch</span>
<span class="sd">              size.</span>
<span class="sd">            The generator is expected to loop over its data</span>
<span class="sd">            indefinitely. An epoch finishes when `steps_per_epoch`</span>
<span class="sd">            batches have been seen by the model.</span>
<span class="sd">        steps_per_epoch: Total number of steps (batches of samples)</span>
<span class="sd">            to yield from `generator` before declaring one epoch</span>
<span class="sd">            finished and starting the next epoch. It should typically</span>
<span class="sd">            be equal to the number of samples of your dataset</span>
<span class="sd">            divided by the batch size.</span>
<span class="sd">            Optional for `Sequence`: if unspecified, will use</span>
<span class="sd">            the `len(generator)` as a number of steps.</span>
<span class="sd">        epochs: Integer, total number of iterations on the data.</span>
<span class="sd">        verbose: Verbosity mode, 0, 1, or 2.</span>
<span class="sd">        callbacks: List of callbacks to be called during training.</span>
<span class="sd">        validation_data: This can be either</span>
<span class="sd">            - a generator for the validation data</span>
<span class="sd">            - a tuple (inputs, targets)</span>
<span class="sd">            - a tuple (inputs, targets, sample_weights).</span>
<span class="sd">        validation_steps: Only relevant if `validation_data`</span>
<span class="sd">            is a generator. Total number of steps (batches of samples)</span>
<span class="sd">            to yield from `generator` before stopping.</span>
<span class="sd">            Optional for `Sequence`: if unspecified, will use</span>
<span class="sd">            the `len(validation_data)` as a number of steps.</span>
<span class="sd">        class_weight: Dictionary mapping class indices to a weight</span>
<span class="sd">            for the class.</span>
<span class="sd">        max_queue_size: Integer. Maximum size for the generator queue.</span>
<span class="sd">            If unspecified, `max_queue_size` will default to 10.</span>
<span class="sd">        workers: Integer. Maximum number of processes to spin up</span>
<span class="sd">            when using process-based threading.</span>
<span class="sd">            If unspecified, `workers` will default to 1. If 0, will</span>
<span class="sd">            execute the generator on the main thread.</span>
<span class="sd">        use_multiprocessing: Boolean.</span>
<span class="sd">            If `True`, use process-based threading.</span>
<span class="sd">            If unspecified, `use_multiprocessing` will default to `False`.</span>
<span class="sd">            Note that because this implementation relies on multiprocessing,</span>
<span class="sd">            you should not pass non-picklable arguments to the generator</span>
<span class="sd">            as they can&#39;t be passed easily to children processes.</span>
<span class="sd">        shuffle: Boolean. Whether to shuffle the order of the batches at</span>
<span class="sd">            the beginning of each epoch. Only used with instances</span>
<span class="sd">            of `Sequence` (`keras.utils.Sequence`).</span>
<span class="sd">            Has no effect when `steps_per_epoch` is not `None`.</span>
<span class="sd">        initial_epoch: Epoch at which to start training</span>
<span class="sd">            (useful for resuming a previous training run)</span>

<span class="sd">    Returns:</span>
<span class="sd">        A `History` object.</span>

<span class="sd">    Example:</span>

<span class="sd">    ```python</span>
<span class="sd">        def generate_arrays_from_file(path):</span>
<span class="sd">            while 1:</span>
<span class="sd">                f = open(path)</span>
<span class="sd">                for line in f:</span>
<span class="sd">                    # create numpy arrays of input data</span>
<span class="sd">                    # and labels, from each line in the file</span>
<span class="sd">                    x1, x2, y = process_line(line)</span>
<span class="sd">                    yield ({&#39;input_1&#39;: x1, &#39;input_2&#39;: x2}, {&#39;output&#39;: y})</span>
<span class="sd">                f.close()</span>

<span class="sd">        model.fit_generator(generate_arrays_from_file(&#39;/my_file.txt&#39;),</span>
<span class="sd">                            steps_per_epoch=10000, epochs=10)</span>
<span class="sd">    ```</span>
<span class="sd">    Raises:</span>
<span class="sd">        ValueError: In case the generator yields</span>
<span class="sd">            data in an invalid format.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">built</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_graph_network</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
          <span class="s1">&#39;`fit_generator` is not yet enabled for unbuilt Model subclasses&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">training_generator</span><span class="o">.</span><span class="n">fit_generator</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">generator</span><span class="p">,</span>
        <span class="n">steps_per_epoch</span><span class="o">=</span><span class="n">steps_per_epoch</span><span class="p">,</span>
        <span class="n">epochs</span><span class="o">=</span><span class="n">epochs</span><span class="p">,</span>
        <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
        <span class="n">callbacks</span><span class="o">=</span><span class="n">callbacks</span><span class="p">,</span>
        <span class="n">validation_data</span><span class="o">=</span><span class="n">validation_data</span><span class="p">,</span>
        <span class="n">validation_steps</span><span class="o">=</span><span class="n">validation_steps</span><span class="p">,</span>
        <span class="n">class_weight</span><span class="o">=</span><span class="n">class_weight</span><span class="p">,</span>
        <span class="n">max_queue_size</span><span class="o">=</span><span class="n">max_queue_size</span><span class="p">,</span>
        <span class="n">workers</span><span class="o">=</span><span class="n">workers</span><span class="p">,</span>
        <span class="n">use_multiprocessing</span><span class="o">=</span><span class="n">use_multiprocessing</span><span class="p">,</span>
        <span class="n">shuffle</span><span class="o">=</span><span class="n">shuffle</span><span class="p">,</span>
        <span class="n">initial_epoch</span><span class="o">=</span><span class="n">initial_epoch</span><span class="p">)</span></div>

<div class="viewcode-block" id="Model.evaluate_generator"><a class="viewcode-back" href="../zf.html#zf.Model.evaluate_generator">[docs]</a>  <span class="k">def</span> <span class="nf">evaluate_generator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                         <span class="n">generator</span><span class="p">,</span>
                         <span class="n">steps</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                         <span class="n">max_queue_size</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
                         <span class="n">workers</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                         <span class="n">use_multiprocessing</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Evaluates the model on a data generator.</span>

<span class="sd">    The generator should return the same kind of data</span>
<span class="sd">    as accepted by `test_on_batch`.</span>

<span class="sd">    Arguments:</span>
<span class="sd">        generator: Generator yielding tuples (inputs, targets)</span>
<span class="sd">            or (inputs, targets, sample_weights)</span>
<span class="sd">            or an instance of Sequence (keras.utils.Sequence)</span>
<span class="sd">            object in order to avoid duplicate data</span>
<span class="sd">            when using multiprocessing.</span>
<span class="sd">        steps: Total number of steps (batches of samples)</span>
<span class="sd">            to yield from `generator` before stopping.</span>
<span class="sd">            Optional for `Sequence`: if unspecified, will use</span>
<span class="sd">            the `len(generator)` as a number of steps.</span>
<span class="sd">        max_queue_size: maximum size for the generator queue</span>
<span class="sd">        workers: Integer. Maximum number of processes to spin up</span>
<span class="sd">            when using process-based threading.</span>
<span class="sd">            If unspecified, `workers` will default to 1. If 0, will</span>
<span class="sd">            execute the generator on the main thread.</span>
<span class="sd">        use_multiprocessing: Boolean.</span>
<span class="sd">            If `True`, use process-based threading.</span>
<span class="sd">            If unspecified, `use_multiprocessing` will default to `False`.</span>
<span class="sd">            Note that because this implementation relies on multiprocessing,</span>
<span class="sd">            you should not pass non-picklable arguments to the generator</span>
<span class="sd">            as they can&#39;t be passed easily to children processes.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Scalar test loss (if the model has a single output and no metrics)</span>
<span class="sd">        or list of scalars (if the model has multiple outputs</span>
<span class="sd">        and/or metrics). The attribute `model.metrics_names` will give you</span>
<span class="sd">        the display labels for the scalar outputs.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: in case of invalid arguments.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: In case the generator yields</span>
<span class="sd">            data in an invalid format.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">built</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_graph_network</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
          <span class="s1">&#39;`evaluate_generator` is not yet enabled for &#39;</span>
          <span class="s1">&#39;unbuilt Model subclasses&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">training_generator</span><span class="o">.</span><span class="n">evaluate_generator</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">generator</span><span class="p">,</span>
        <span class="n">steps</span><span class="o">=</span><span class="n">steps</span><span class="p">,</span>
        <span class="n">max_queue_size</span><span class="o">=</span><span class="n">max_queue_size</span><span class="p">,</span>
        <span class="n">workers</span><span class="o">=</span><span class="n">workers</span><span class="p">,</span>
        <span class="n">use_multiprocessing</span><span class="o">=</span><span class="n">use_multiprocessing</span><span class="p">)</span></div>

<div class="viewcode-block" id="Model.predict_generator"><a class="viewcode-back" href="../zf.html#zf.Model.predict_generator">[docs]</a>  <span class="k">def</span> <span class="nf">predict_generator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                        <span class="n">generator</span><span class="p">,</span>
                        <span class="n">steps</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                        <span class="n">max_queue_size</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
                        <span class="n">workers</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                        <span class="n">use_multiprocessing</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                        <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Generates predictions for the input samples from a data generator.</span>

<span class="sd">    The generator should return the same kind of data as accepted by</span>
<span class="sd">    `predict_on_batch`.</span>

<span class="sd">    Arguments:</span>
<span class="sd">        generator: Generator yielding batches of input samples</span>
<span class="sd">            or an instance of Sequence (keras.utils.Sequence)</span>
<span class="sd">            object in order to avoid duplicate data</span>
<span class="sd">            when using multiprocessing.</span>
<span class="sd">        steps: Total number of steps (batches of samples)</span>
<span class="sd">            to yield from `generator` before stopping.</span>
<span class="sd">            Optional for `Sequence`: if unspecified, will use</span>
<span class="sd">            the `len(generator)` as a number of steps.</span>
<span class="sd">        max_queue_size: Maximum size for the generator queue.</span>
<span class="sd">        workers: Integer. Maximum number of processes to spin up</span>
<span class="sd">            when using process-based threading.</span>
<span class="sd">            If unspecified, `workers` will default to 1. If 0, will</span>
<span class="sd">            execute the generator on the main thread.</span>
<span class="sd">        use_multiprocessing: Boolean.</span>
<span class="sd">            If `True`, use process-based threading.</span>
<span class="sd">            If unspecified, `use_multiprocessing` will default to `False`.</span>
<span class="sd">            Note that because this implementation relies on multiprocessing,</span>
<span class="sd">            you should not pass non-picklable arguments to the generator</span>
<span class="sd">            as they can&#39;t be passed easily to children processes.</span>
<span class="sd">        verbose: verbosity mode, 0 or 1.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Numpy array(s) of predictions.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: In case the generator yields</span>
<span class="sd">            data in an invalid format.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">built</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_graph_network</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
          <span class="s1">&#39;`predict_generator` is not yet enabled for unbuilt Model subclasses&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">training_generator</span><span class="o">.</span><span class="n">predict_generator</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">generator</span><span class="p">,</span>
        <span class="n">steps</span><span class="o">=</span><span class="n">steps</span><span class="p">,</span>
        <span class="n">max_queue_size</span><span class="o">=</span><span class="n">max_queue_size</span><span class="p">,</span>
        <span class="n">workers</span><span class="o">=</span><span class="n">workers</span><span class="p">,</span>
        <span class="n">use_multiprocessing</span><span class="o">=</span><span class="n">use_multiprocessing</span><span class="p">,</span>
        <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span></div></div>

</pre></div>

           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, zfw.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'zfr',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>